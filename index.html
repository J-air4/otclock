<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Refactored Therapy Scheduler</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        /* --- Print Styles --- */
        @media print {
            body {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            .printable-area, .printable-area * {
                visibility: visible;
                background: white !important;
                color: black !important;
            }
            .printable-area {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
            }
            .no-print { display: none; }
            .border, .border-gray-700 { border-color: #ccc !important; }
            .text-yellow-400 { color: #f59e0b !important; }
            .text-green-400 { color: #10b981 !important; }
            .bg-yellow-500\/20 { background-color: rgba(234, 179, 8, 0.2) !important; }
            .bg-blue-500\/20 { background-color: rgba(59, 130, 246, 0.2) !important; }
            .bg-green-500\/20 { background-color: rgba(16, 185, 129, 0.2) !important; }
            .bg-purple-500\/20 { background-color: rgba(139, 92, 246, 0.2) !important; }
        }

        /* --- Animations & Transitions --- */
        @keyframes fade-in-down {
            0% { opacity: 0; transform: translateY(-10px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in-down { animation: fade-in-down 0.3s ease-out forwards; }

        /* --- Custom Component Styles --- */
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: none; 
            margin: 0; 
        }
        input[type=number] {
            -moz-appearance: textfield;
        }

        .timeline-appointment-item {
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .timeline-appointment-item:hover {
            z-index: 20;
            transform: scale(1.02);
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
        }

        /* NEW: Accessibility improvement for hover/focus controls */
        .appointment-actions {
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }
        .timeline-appointment-item:hover .appointment-actions,
        .timeline-appointment-item:focus-within .appointment-actions {
            opacity: 1;
        }


        .timeline-scroll-container {
            max-height: 82vh;
            overflow-y: auto;
            position: relative;
            border-radius: 0.375rem;
        }

        /* --- Drag & Drop Styles --- */
        .dragging {
            opacity: 0.5;
            transform: scale(1.05);
        }

        /* REFACTORED: Combined drop indicator styles */
        .drop-line-indicator {
            position: absolute;
            width: 100%;
            height: 3px;
            border-radius: 2px;
            z-index: 1000;
            display: none;
            pointer-events: none;
            box-shadow: 0 0 8px rgba(0,0,0,0.5);
        }
        .drop-line-indicator.is-valid { background-color: #fbbf24; }
        .drop-line-indicator.is-conflict { background-color: #ef4444; }

        /* --- Validation Styles --- */
        .error-border {
            border-color: #ef4444 !important;
            box-shadow: 0 0 0 1px #ef4444;
        }
        .success-border {
            border-color: #10b981 !important;
            box-shadow: 0 0 0 1px #10b981;
        }
    </style>
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
</head>
<body class="bg-gray-900">
    <div id="app-root"></div>

    <script type="module">
        // === SECURITY & VALIDATION MODULE ===
        class SecurityUtils {
            static sanitizeHTML(str) {
                // IMPROVEMENT: More concise handling of null/undefined
                const div = document.createElement('div');
                div.textContent = String(str ?? '');
                return div.innerHTML;
            }
            static validateTimeString(timeStr) {
                if (!timeStr || typeof timeStr !== 'string') return false;
                const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
                return timeRegex.test(timeStr);
            }
            static validateDuration(duration) {
                const num = parseInt(duration, 10);
                return !isNaN(num) && num >= Constants.MINIMUM_SCHEDULABLE_DURATION && num <= Constants.MAXIMUM_SCHEDULABLE_DURATION;
            }
            static validateLabel(label) {
                if (!label || typeof label !== 'string') return false;
                return label.trim().length > 0 && label.length <= Constants.MAX_LABEL_LENGTH;
            }
            static sanitizeInput(input, type = 'text') {
                if (input === null || input === undefined) return '';
                switch (type) {
                    case 'number':
                        const num = parseInt(input, 10);
                        return isNaN(num) ? 0 : Math.max(0, num);
                    case 'time':
                        return this.validateTimeString(input) ? input : '00:00';
                    case 'label':
                        return String(input).trim().substring(0, Constants.MAX_LABEL_LENGTH);
                    default:
                        return this.sanitizeHTML(input);
                }
            }
        }

        // === ERROR HANDLING MODULE ===
        class ErrorHandler {
            static logError(error, context = '') {
                console.error(`[TherapySchedulerApp] ${context}:`, error);
            }
            static showUserError(message, container = null) {
                NotificationSystem.show(message, 'error');
                if (container) {
                    container.classList.add('error-border');
                    setTimeout(() => container.classList.remove('error-border'), 3000);
                }
            }
            static handleStorageError(operation, fallback = null) {
                try {
                    return operation();
                } catch (error) {
                    this.logError(error, 'Storage');
                    this.showUserError('Storage operation failed. Your changes may not be saved.');
                    return fallback;
                }
            }
        }

        // === CONSTANTS ===
        const Constants = {
            MINIMUM_SCHEDULABLE_DURATION: 5,
            MAXIMUM_SCHEDULABLE_DURATION: 480,
            PIXELS_PER_HOUR: 120,
            APPOINTMENT_SMALL_FONT_THRESHOLD_PX: 25,
            APPOINTMENT_HIDE_TIME_THRESHOLD_PX: 20,
            MAX_WORKDAY_HOURS: 16,
            MAX_LABEL_LENGTH: 100,
            DEBOUNCE_DELAY: 50,
            ACTIONS: {
                SAVE: 'save', PRINT: 'print', CLEAR_DAY: 'clear-day', CONFIRM_CLEAR: 'confirm-clear', CANCEL_CLEAR: 'cancel-clear',
                ADD_PATIENT: 'add-patient', ADD_PATIENT_PRESET: 'add-patient-preset', REMOVE_PATIENT: 'remove-patient',
                AUTO_SCHEDULE: 'auto-schedule', EDIT_APPOINTMENT: 'edit-appointment', DELETE_APPOINTMENT: 'delete-appointment',
                TOGGLE_COMPLETE: 'toggle-complete', ADD_BREAK: 'add-break', DELETE_BREAK: 'delete-break', ADD_TASK: 'add-task',
                DELETE_TASK: 'delete-task', CANCEL_EDIT: 'cancel-edit', SAVE_EDIT: 'save-edit', TOGGLE_ADMIN_SETTINGS: 'toggle-admin-settings',
            }
        };

        // === ICONS ===
        const Icons = {
            Clock: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>`,
            Plus: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="M12 5v14"/></svg>`,
            Trash2: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>`,
            Calendar: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="4" rx="2" ry="2"/><line x1="16" x2="16" y1="2" y2="6"/><line x1="8" x2="8" y1="2" y2="6"/><line x1="3" x2="21" y1="10" y2="10"/></svg>`,
            AlertCircle: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/></svg>`,
            CheckCircle: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>`,
            Coffee: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 8h1a4 4 0 1 1 0 8h-1"/><path d="M3 8h14v9a4 4 0 0 1-4 4H7a4 4 0 0 1-4-4Z"/><line x1="6" x2="6" y1="2" y2="4"/><line x1="10" x2="10" y1="2" y2="4"/><line x1="14" x2="14" y1="2" y2="4"/></svg>`,
            Save: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>`,
            Briefcase: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="20" height="14" x="2" y="7" rx="2" ry="2"/><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"/></svg>`,
            BrainCircuit: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5a3 3 0 1 0-5.993.142"/><path d="M12 5a3 3 0 1 1 5.993.142"/><path d="M15 13a3 3 0 1 0-5.993.142"/><path d="M15 13a3 3 0 1 1 5.993.142"/><path d="M9 13a3 3 0 1 1 5.993.142"/><path d="M9 13a3 3 0 1 0-5.993.142"/><path d="M6 8.5A2.5 2.5 0 0 1 3.5 6v0A2.5 2.5 0 0 1 6 3.5V0"/><path d="M18 8.5A2.5 2.5 0 0 0 20.5 6v0A2.5 2.5 0 0 0 18 3.5V0"/><path d="M9 22a2.5 2.5 0 0 0 2.5-2.5v-1A2.5 2.5 0 0 0 9 16h0a2.5 2.5 0 0 0-2.5 2.5v1A2.5 2.5 0 0 0 9 22Z"/><path d="M15 22a2.5 2.5 0 0 1-2.5-2.5v-1A2.5 2.5 0 0 1 15 16h0a2.5 2.5 0 0 1 2.5 2.5v1A2.5 2.5 0 0 1 15 22Z"/><path d="M12 13a2.5 2.5 0 0 0 2.5-2.5v-1A2.5 2.5 0 0 0 12 7h0a2.5 2.5 0 0 0-2.5 2.5v1A2.5 2.5 0 0 0 12 13Z"/><path d="M12 5.5V7"/><path d="M15 13v-1.5"/><path d="M9 13v-1.5"/><path d="M18 8.5v1"/><path d="M6 8.5v1"/></svg>`,
            Printer: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 6 2 18 2 18 9"/><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/><rect width="12" height="8" x="6" y="14"/></svg>`,
            X: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" x2="6" y1="6" y2="18"/><line x1="6" x2="18" y1="6" y2="18"/></svg>`,
            Zap: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>`,
            Edit: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>`,
            ChevronDown: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m6 9 6 6 6-6"/></svg>`,
        };

        const getIcon = (name, size = 16) => {
            const svg = Icons[name] || '';
            return svg.replace('width="24"', `width="${size}"`).replace('height="24"', `height="${size}"`);
        }

        // === UTILITY FUNCTIONS ===
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // === NOTIFICATION SYSTEM ===
        class NotificationSystem {
            static show(message, type = 'info', duration = 5000) {
                const container = document.getElementById('notification-container');
                if (!container) return;
                const notification = document.createElement('div');
                const typeClasses = { success: "bg-gray-800 border-green-500 text-green-300", error: "bg-gray-800 border-red-500 text-red-300", warning: "bg-gray-800 border-yellow-500 text-yellow-300", info: "bg-gray-800 border-blue-500 text-blue-300" };
                const icon = type === 'success' ? getIcon('CheckCircle', 20) : getIcon('AlertCircle', 20);
                notification.className = `fixed top-5 right-5 z-50 flex items-center gap-3 px-4 py-3 rounded-lg shadow-lg animate-fade-in-down border ${typeClasses[type]}`;
                // ACCESSIBILITY: Add role="alert" for screen readers
                notification.setAttribute('role', 'alert');
                notification.innerHTML = `${icon}<span>${SecurityUtils.sanitizeHTML(message)}</span><button class="ml-4 p-1 rounded-full hover:bg-white/10" onclick="this.parentElement.remove()" aria-label="Close notification">${getIcon('X', 16)}</button>`;
                container.appendChild(notification);
                if (duration > 0) {
                    setTimeout(() => { if (notification.parentElement) { notification.remove(); } }, duration);
                }
            }
        }

        // === TIME UTILITIES ===
        class TimeUtils {
            static minutesToTime(totalMinutes) {
                if (isNaN(totalMinutes) || totalMinutes < 0) return 'Invalid Time';
                const hours24 = Math.floor(totalMinutes / 60);
                const minutes = Math.round(totalMinutes % 60);
                const period = (hours24 % 24) >= 12 ? 'PM' : 'AM';
                let displayHours = hours24 % 12;
                if (displayHours === 0) displayHours = 12;
                return `${displayHours}:${minutes.toString().padStart(2, '0')} ${period}`;
            }
            static timeStringToMinutes(time24h) {
                if (!time24h || !SecurityUtils.validateTimeString(time24h)) return 0;
                const [hours, minutes] = time24h.split(':').map(Number);
                return hours * 60 + minutes;
            }
            static minutesTo24hTime(totalMinutes) {
                if (isNaN(totalMinutes) || totalMinutes < 0) return '00:00';
                const hours24 = Math.floor(totalMinutes / 60) % 24;
                const minutes = Math.round(totalMinutes % 60);
                return `${String(hours24).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
            }
            static isValidTimeRange(startTime, endTime) {
                return this.timeStringToMinutes(endTime) > this.timeStringToMinutes(startTime);
            }
        }

        // === CONFLICT DETECTION LOGIC ===
        class ConflictDetector {
            static checkForConflicts(newStartMins, newDuration, appointments, breaks, otherTasks, transitionTime, excludeId = null) {
                const newEndMins = newStartMins + newDuration + transitionTime;
                for (const apt of appointments) {
                    if (excludeId && apt.id === excludeId) continue;
                    const aptStartMins = TimeUtils.timeStringToMinutes(apt.start);
                    const aptEndMins = aptStartMins + apt.duration + transitionTime;
                    if (this.timesOverlap(newStartMins, newEndMins, aptStartMins, aptEndMins)) {
                        return { hasConflict: true, conflictType: 'appointment', conflictItem: apt };
                    }
                }
                const allBlocks = [...breaks, ...otherTasks];
                for (const block of allBlocks) {
                    const blockStartMins = TimeUtils.timeStringToMinutes(block.start);
                    const blockEndMins = TimeUtils.timeStringToMinutes(block.end);
                    if (this.timesOverlap(newStartMins, newEndMins, blockStartMins, blockEndMins)) {
                        return { hasConflict: true, conflictType: block.type || 'task', conflictItem: block };
                    }
                }
                return { hasConflict: false };
            }
            static timesOverlap(start1, end1, start2, end2) {
                return start1 < end2 && start2 < end1;
            }
        }

        // === STATE MANAGEMENT ===
        class StateManager {
            constructor() {
                this.state = this.createInitialState();
                this.listeners = [];
                this.undoStack = [];
                this.redoStack = [];
            }
            createInitialState() {
                return {
                    settings: { workDay: { startTime: '08:30' }, breaks: [], otherTasks: [], transitionTime: 2, setupTime: 5, productivityTarget: 93, workdayDurationHours: 12 },
                    appointments: [],
                    patientQueue: [],
                    schedule: null,
                    modals: { clearDay: false, editAppointment: false, editingAppointment: null },
                    dragState: { draggedPatientId: null, draggedElement: null, dropPosition: null, hasConflict: false },
                    ui: { patientCounter: 1, isSettingsPanelOpen: true, isAdminSettingsOpen: false }
                };
            }
            subscribe(listener) {
                this.listeners.push(listener);
                return () => { this.listeners = this.listeners.filter(l => l !== listener); };
            }
            setState(updates, saveToHistory = true) {
                if (saveToHistory) {
                    this.undoStack.push(JSON.parse(JSON.stringify(this.state)));
                    if (this.undoStack.length > 50) this.undoStack.shift();
                    this.redoStack = [];
                }
                this.state = { ...this.state, ...updates };
                this.notifyListeners(saveToHistory);
            }
            // NOTE: This deep update logic is complex. For larger applications,
            // a library like Immer or a dedicated utility function would be safer.
            updateSettings(path, value) {
                const newSettings = JSON.parse(JSON.stringify(this.state.settings));
                let current = newSettings;
                const parts = path.split('.');
                for (let i = 0; i < parts.length - 1; i++) { current = current[parts[i]]; }
                current[parts[parts.length - 1]] = value;
                this.setState({ settings: newSettings });
            }
            notifyListeners(saveToHistory = true) {
                this.listeners.forEach(listener => {
                    try { listener(this.state, saveToHistory); }
                    catch (error) { ErrorHandler.logError(error, 'StateListener'); }
                });
            }
            undo() {
                if (this.undoStack.length > 0) {
                    this.redoStack.push(JSON.parse(JSON.stringify(this.state)));
                    this.state = this.undoStack.pop();
                    this.notifyListeners();
                }
            }
            redo() {
                if (this.redoStack.length > 0) {
                    this.undoStack.push(JSON.parse(JSON.stringify(this.state)));
                    this.state = this.redoStack.pop();
                    this.notifyListeners();
                }
            }
        }

        // === DATA PERSISTENCE ===
        class StorageManager {
            static KEYS = { SETTINGS: 'therapySchedulerSettings', APPOINTMENTS: 'therapySchedulerAppointments', QUEUE: 'therapySchedulerQueue' };
            static save(key, data) { return ErrorHandler.handleStorageError(() => { localStorage.setItem(key, JSON.stringify(data)); return true; }, false); }
            static load(key, defaultValue = null) { return ErrorHandler.handleStorageError(() => { const item = localStorage.getItem(key); return item ? JSON.parse(item) : defaultValue; }, defaultValue); }
            static saveAll(state) {
                const results = [this.save(this.KEYS.SETTINGS, state.settings), this.save(this.KEYS.APPOINTMENTS, state.appointments), this.save(this.KEYS.QUEUE, state.patientQueue)];
                return results.every(result => result);
            }
            static loadAll() { return { settings: this.load(this.KEYS.SETTINGS), appointments: this.load(this.KEYS.APPOINTMENTS, []), patientQueue: this.load(this.KEYS.QUEUE, []) }; }
        }

        // === VALIDATION ===
        class ValidationManager {
            static validateAppointment(appointment) {
                const errors = [];
                if (!appointment.name || !SecurityUtils.validateLabel(appointment.name)) { errors.push('Invalid appointment name'); }
                if (!SecurityUtils.validateDuration(appointment.duration)) { errors.push(`Duration must be between ${Constants.MINIMUM_SCHEDULABLE_DURATION} and ${Constants.MAXIMUM_SCHEDULABLE_DURATION} minutes`); }
                if (!SecurityUtils.validateTimeString(appointment.start)) { errors.push('Invalid start time format'); }
                return errors;
            }
            static validateBreakOrTask(item) {
                const errors = [];
                if (!item.label || !SecurityUtils.validateLabel(item.label)) { errors.push('Invalid label'); }
                if (!SecurityUtils.validateTimeString(item.start) || !SecurityUtils.validateTimeString(item.end)) { errors.push('Invalid time format'); }
                if (!TimeUtils.isValidTimeRange(item.start, item.end)) { errors.push('End time must be after start time'); }
                return errors;
            }
            static validateSettings(settings) {
                const errors = [];
                if (!SecurityUtils.validateTimeString(settings.workDay.startTime)) { errors.push('Invalid work start time'); }
                if (settings.transitionTime < 0 || settings.transitionTime > 60) { errors.push('Transition time must be between 0 and 60 minutes'); }
                if (settings.setupTime < 0 || settings.setupTime > 120) { errors.push('Setup time must be between 0 and 120 minutes'); }
                if (settings.productivityTarget < 0 || settings.productivityTarget > 100) { errors.push('Productivity target must be between 0 and 100 percent'); }
                if (settings.workdayDurationHours < 1 || settings.workdayDurationHours > Constants.MAX_WORKDAY_HOURS) { errors.push(`Workday duration must be between 1 and ${Constants.MAX_WORKDAY_HOURS} hours`); }
                return errors;
            }
        }

        // === BUSINESS LOGIC / CALCULATIONS ===
        class ScheduleCalculator {
            static calculateAppointmentLayout(items) {
                const appointments = items.filter(item => item.type === 'appointment');
                const otherItems = items.filter(item => item.type !== 'appointment');
                if (appointments.length === 0) return items;
                appointments.sort((a, b) => a.startMins - b.startMins);
                const active = [];
                for (const appt of appointments) {
                    let i = active.length;
                    while (i--) { if (active[i].endMins <= appt.startMins) { active.splice(i, 1); } }
                    const occupiedLanes = active.map(a => a.layout.lane);
                    let lane = 0;
                    while (occupiedLanes.includes(lane)) { lane++; }
                    appt.layout = { lane: lane, totalLanes: 1 };
                    active.push(appt);
                    const totalLanes = active.reduce((max, a) => Math.max(max, a.layout.lane), 0) + 1;
                    for (const activeAppt of active) { activeAppt.layout.totalLanes = Math.max(activeAppt.layout.totalLanes, totalLanes); }
                }
                return [...appointments, ...otherItems].sort((a, b) => a.startMins - b.startMins);
            }
            static calculateScheduleMetrics(state) {
                try {
                    const allScheduledItems = [
                        ...state.settings.breaks.map(b => ({ ...b, type: 'break', startMins: TimeUtils.timeStringToMinutes(b.start), endMins: TimeUtils.timeStringToMinutes(b.end) })),
                        ...state.settings.otherTasks.map(t => ({ ...t, type: t.type, startMins: TimeUtils.timeStringToMinutes(t.start), endMins: TimeUtils.timeStringToMinutes(t.end) })),
                        ...state.appointments.map(a => ({ ...a, type: 'appointment', startMins: TimeUtils.timeStringToMinutes(a.start), endMins: TimeUtils.timeStringToMinutes(a.start) + a.duration }))
                    ].sort((a, b) => a.startMins - b.startMins);
                    const dayStartMins = TimeUtils.timeStringToMinutes(state.settings.workDay.startTime);
                    let lastEnd = dayStartMins + state.settings.setupTime;
                    allScheduledItems.forEach(item => {
                        const effectiveEndMins = item.type === 'appointment' ? item.endMins + state.settings.transitionTime : item.endMins;
                        lastEnd = Math.max(lastEnd, effectiveEndMins);
                    });
                    const gaps = this.calculateGaps(allScheduledItems, dayStartMins, state.settings);
                    const metrics = this.calculateProductivityMetrics(state, allScheduledItems);
                    const suggestions = this.generateSuggestions(state, gaps, lastEnd, metrics);
                    return { timelineItems: [...allScheduledItems, ...gaps.map(g => ({ ...g, startMins: g.start, endMins: g.end }))].sort((a, b) => a.startMins - b.startMins), ...metrics, suggestions, lastEndMins: lastEnd, gaps };
                } catch (error) { ErrorHandler.logError(error, 'ScheduleCalculation'); return null; }
            }
            static calculateGaps(allScheduledItems, dayStartMins, settings) {
                const gaps = [];
                let lastGapCheck = dayStartMins + settings.setupTime;
                allScheduledItems.forEach(item => {
                    if (item.startMins > lastGapCheck) { gaps.push({ id: `gap-${lastGapCheck}`, start: lastGapCheck, end: item.startMins, duration: item.startMins - lastGapCheck, type: 'gap' }); }
                    const effectiveEndMins = item.type === 'appointment' ? item.endMins + settings.transitionTime : item.endMins;
                    lastGapCheck = Math.max(lastGapCheck, effectiveEndMins);
                });
                const dayEndMins = dayStartMins + (settings.workdayDurationHours * 60);
                if (dayEndMins > lastGapCheck) {
                    gaps.push({ id: `gap-end-${lastGapCheck}`, start: lastGapCheck, end: dayEndMins, duration: dayEndMins - lastGapCheck, type: 'gap' });
                }
                return gaps;
            }
            static calculateProductivityMetrics(state, allScheduledItems) {
                const totalTreatmentTime = state.appointments.reduce((sum, apt) => sum + apt.duration, 0);
                const billableTaskTime = state.settings.otherTasks.filter(t => t.type === 'billable').reduce((sum, t) => sum + (TimeUtils.timeStringToMinutes(t.end) - TimeUtils.timeStringToMinutes(t.start)), 0);
                const nonBillableTaskTime = state.settings.otherTasks.filter(t => t.type === 'non-billable').reduce((sum, t) => sum + (TimeUtils.timeStringToMinutes(t.end) - TimeUtils.timeStringToMinutes(t.start)), 0);
                const totalBreakTime = state.settings.breaks.reduce((sum, br) => sum + (TimeUtils.timeStringToMinutes(br.end) - TimeUtils.timeStringToMinutes(br.start)), 0);
                const totalBillableTime = totalTreatmentTime + billableTaskTime;
                const timeUnavailable = totalBreakTime + nonBillableTaskTime;
                let projectedClockOutMins = 0; let productivity = 0;
                if (state.settings.productivityTarget > 0 && totalBillableTime > 0) {
                    const dayStartMins = TimeUtils.timeStringToMinutes(state.settings.workDay.startTime);
                    const requiredTotalWorkTime = (totalBillableTime / (state.settings.productivityTarget / 100));
                    projectedClockOutMins = dayStartMins + requiredTotalWorkTime + timeUnavailable;
                    const lastEnd = Math.max(0, ...allScheduledItems.map(item => item.type === 'appointment' ? item.endMins + state.settings.transitionTime : item.endMins));
                    const totalWorkTime = lastEnd - dayStartMins;
                    const totalProductiveTimePossible = totalWorkTime - timeUnavailable;
                    if (totalProductiveTimePossible > 0) { productivity = ((totalBillableTime / totalProductiveTimePossible) * 100); }
                }
                return { totalBillableTime, timeUnavailable, projectedClockOutMins, productivity: Number(productivity.toFixed(1)), meetsTarget: projectedClockOutMins > 0 && allScheduledItems.length > 0 };
            }
            static generateSuggestions(state, gaps, lastEnd, metrics) {
                const suggestions = [];
                if (metrics.projectedClockOutMins > 0) {
                    suggestions.push(`To meet your <b>${state.settings.productivityTarget}% target</b>, you should clock out around <b>${TimeUtils.minutesToTime(metrics.projectedClockOutMins)}</b>.`);
                } else {
                    suggestions.push(`Add appointments to calculate your productivity and target clock-out time.`);
                }
                if (state.patientQueue.length > 0 && gaps.length > 0) {
                    const smallestPatientDuration = Math.min(...state.patientQueue.map(p => p.duration));
                    const suitableGap = gaps.find(g => g.duration >= smallestPatientDuration + state.settings.transitionTime);
                    if (suitableGap) { suggestions.push(`You have a <b>${suitableGap.duration} min gap</b> at ${TimeUtils.minutesToTime(suitableGap.start)} large enough for a queued session.`); }
                }
                if (lastEnd > 19 * 60) { suggestions.push(`<b>Warning:</b> Your current schedule ends at <b>${TimeUtils.minutesToTime(lastEnd)}</b>.`); }
                return suggestions;
            }
        }

        // === APPLICATION CONTROLLER ===
        class TherapySchedulerApp {
            constructor() {
                this.stateManager = new StateManager();
                this.renderer = new AppRenderer(this.stateManager);
                this.eventHandler = new EventHandler(this.stateManager, this);
                this.stateManager.subscribe((state, saveToHistory) => {
                    if (saveToHistory) { this.updateSchedule(); }
                    this.renderer.update(state); // Pass state to update
                });
                this.init();
            }
            init() {
                try {
                    this.renderer.initialRender();
                    this.loadData();
                    this.setupEventListeners();
                    this.updateSchedule();
                    this.stateManager.notifyListeners();
                } catch (error) { ErrorHandler.logError(error, 'AppInit'); NotificationSystem.show('Failed to initialize application', 'error'); }
            }
            loadData() {
                const saved = StorageManager.loadAll();
                const updates = {};
                const initialState = this.stateManager.createInitialState();
                if (saved.settings) {
                    if (ValidationManager.validateSettings(saved.settings).length === 0) { updates.settings = { ...initialState.settings, ...saved.settings }; }
                    else { NotificationSystem.show('Invalid settings detected, using defaults', 'warning'); }
                }
                if (saved.appointments) {
                    const validAppointments = saved.appointments.filter(apt => ValidationManager.validateAppointment(apt).length === 0);
                    updates.appointments = validAppointments;
                    if (validAppointments.length !== saved.appointments.length) { NotificationSystem.show('Some invalid appointments were removed', 'warning'); }
                }
                if (saved.patientQueue) { updates.patientQueue = saved.patientQueue; }
                if (Object.keys(updates).length > 0) { this.stateManager.setState(updates, false); }
                const allPatients = [...(updates.appointments || []), ...(updates.patientQueue || [])];
                const maxId = allPatients.reduce((max, patient) => {
                    const num = parseInt(patient.name?.replace('P', ''), 10);
                    return isNaN(num) ? max : Math.max(max, num);
                }, 0);
                this.stateManager.setState({ ui: { ...this.stateManager.state.ui, patientCounter: maxId + 1 } }, false);
            }
            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        switch (e.key) {
                            case 'z': e.preventDefault(); e.shiftKey ? this.stateManager.redo() : this.stateManager.undo(); break;
                            case 's': e.preventDefault(); this.saveAll(); break;
                        }
                    }
                });
                window.addEventListener('beforeunload', () => this.saveAll());
            }
            updateSchedule() {
                const schedule = ScheduleCalculator.calculateScheduleMetrics(this.stateManager.state);
                this.stateManager.setState({ schedule }, false);
            }
            saveAll() {
                if (StorageManager.saveAll(this.stateManager.state)) { NotificationSystem.show('Settings and schedule saved!', 'success'); }
                else { NotificationSystem.show('Failed to save settings', 'error'); }
            }
            addPatientToQueue(duration) {
                if (!SecurityUtils.validateDuration(duration)) {
                    NotificationSystem.show(`Duration must be between ${Constants.MINIMUM_SCHEDULABLE_DURATION} and ${Constants.MAXIMUM_SCHEDULABLE_DURATION} minutes.`, 'error');
                    return;
                }
                const state = this.stateManager.state;
                const newPatient = { id: `p${Date.now()}`, name: `P${state.ui.patientCounter}`, duration: SecurityUtils.sanitizeInput(duration, 'number') };
                this.stateManager.setState({ patientQueue: [...state.patientQueue, newPatient], ui: { ...state.ui, patientCounter: state.ui.patientCounter + 1 } });
                NotificationSystem.show(`Patient ${newPatient.name} added to queue.`, 'success');
            }
            removePatientFromQueue(id) {
                this.stateManager.setState({ patientQueue: this.stateManager.state.patientQueue.filter(p => p.id !== id) });
            }
            autoSchedule() {
                let { patientQueue, appointments, settings } = this.stateManager.state;
                if (patientQueue.length === 0) { NotificationSystem.show("Patient queue is empty.", "info"); return; }
                const sortedQueue = [...patientQueue].sort((a, b) => b.duration - a.duration);
                const newAppointments = [...appointments];
                const scheduledPatientIds = new Set();
                let tempState = { ...this.stateManager.state, appointments: newAppointments };
                sortedQueue.forEach(patient => {
                    const tempSchedule = ScheduleCalculator.calculateScheduleMetrics(tempState);
                    const requiredDuration = patient.duration + settings.transitionTime;
                    const suitableGap = tempSchedule.gaps.find(g => g.duration >= requiredDuration);
                    if (suitableGap) {
                        newAppointments.push({ ...patient, id: `appt-${Date.now()}-${patient.id}`, start: TimeUtils.minutesTo24hTime(suitableGap.start), completed: false });
                        scheduledPatientIds.add(patient.id);
                        tempState = { ...tempState, appointments: newAppointments };
                    }
                });
                if (scheduledPatientIds.size > 0) {
                    this.stateManager.setState({ appointments: newAppointments, patientQueue: patientQueue.filter(p => !scheduledPatientIds.has(p.id)) });
                    NotificationSystem.show(`${scheduledPatientIds.size} patient(s) auto-scheduled!`, "success");
                } else { NotificationSystem.show("No suitable gaps found to schedule patients.", "warning"); }
            }
            clearDay() {
                this.stateManager.setState({ appointments: [], patientQueue: [], ui: { ...this.stateManager.state.ui, patientCounter: 1 } });
                StorageManager.save(StorageManager.KEYS.APPOINTMENTS, []);
                StorageManager.save(StorageManager.KEYS.QUEUE, []);
                NotificationSystem.show('Your schedule has been cleared.', 'success');
            }
        }

        // === UI EVENT HANDLING ===
        class EventHandler {
            constructor(stateManager, app) {
                this.stateManager = stateManager;
                this.app = app;
                this.debouncedDragHandler = debounce(this.handleDragOverDebounced.bind(this), Constants.DEBOUNCE_DELAY);
                this.setupDelegatedEvents();
            }
            setupDelegatedEvents() {
                const root = document.getElementById('app-root');
                root.addEventListener('click', this.handleClick.bind(this));
                root.addEventListener('input', this.handleInput.bind(this));
                root.addEventListener('change', this.handleChange.bind(this));
                root.addEventListener('keydown', this.handleKeydown.bind(this));
                root.addEventListener('dragstart', this.handleDragStart.bind(this));
                root.addEventListener('dragend', this.handleDragEnd.bind(this));
                root.addEventListener('dragover', this.handleDragOver.bind(this));
                root.addEventListener('dragleave', this.handleDragLeave.bind(this));
                root.addEventListener('drop', this.handleDrop.bind(this));
            }
            handleClick(e) {
                const actionTarget = e.target.closest('[data-action]');
                if (!actionTarget) return;
                const { action, id, patientId, duration } = actionTarget.dataset;
                try {
                    switch (action) {
                        case Constants.ACTIONS.SAVE: this.app.saveAll(); break;
                        case Constants.ACTIONS.PRINT: window.print(); break;
                        case Constants.ACTIONS.CLEAR_DAY: this.stateManager.setState({ modals: { ...this.stateManager.state.modals, clearDay: true } }); break;
                        case Constants.ACTIONS.CONFIRM_CLEAR: this.app.clearDay(); this.stateManager.setState({ modals: { ...this.stateManager.state.modals, clearDay: false } }); break;
                        case Constants.ACTIONS.CANCEL_CLEAR: this.stateManager.setState({ modals: { ...this.stateManager.state.modals, clearDay: false } }); break;
                        case Constants.ACTIONS.ADD_PATIENT: this.addPatient(); break;
                        case Constants.ACTIONS.ADD_PATIENT_PRESET: this.app.addPatientToQueue(parseInt(duration, 10)); break;
                        case Constants.ACTIONS.REMOVE_PATIENT: this.app.removePatientFromQueue(patientId); break;
                        case Constants.ACTIONS.AUTO_SCHEDULE: this.app.autoSchedule(); break;
                        case Constants.ACTIONS.EDIT_APPOINTMENT: this.openEditModal(id); break;
                        case Constants.ACTIONS.DELETE_APPOINTMENT: this.deleteAppointment(id); break;
                        case Constants.ACTIONS.TOGGLE_COMPLETE: this.toggleAppointmentComplete(id); break;
                        case Constants.ACTIONS.ADD_BREAK: this.addBreak(); break;
                        case Constants.ACTIONS.DELETE_BREAK: this.deleteBreak(id); break;
                        case Constants.ACTIONS.ADD_TASK: this.addTask(); break;
                        case Constants.ACTIONS.DELETE_TASK: this.deleteTask(id); break;
                        case Constants.ACTIONS.CANCEL_EDIT: this.closeEditModal(); break;
                        case Constants.ACTIONS.SAVE_EDIT: this.saveAppointmentChanges(); break;
                        case Constants.ACTIONS.TOGGLE_ADMIN_SETTINGS: this.stateManager.setState({ ui: { ...this.stateManager.state.ui, isAdminSettingsOpen: !this.stateManager.state.ui.isAdminSettingsOpen } }, false); break;
                        default: if (actionTarget.tagName === 'BUTTON') console.warn('Unknown action:', action);
                    }
                } catch (error) { ErrorHandler.logError(error, 'EventHandler'); NotificationSystem.show('An error occurred', 'error'); }
            }
            openEditModal(appointmentId) {
                const appointment = this.stateManager.state.appointments.find(a => a.id === appointmentId);
                if (appointment) { this.stateManager.setState({ modals: { ...this.stateManager.state.modals, editAppointment: true, editingAppointment: { ...appointment } } }); }
            }
            closeEditModal() {
                this.stateManager.setState({ modals: { ...this.stateManager.state.modals, editAppointment: false, editingAppointment: null } });
            }
            saveAppointmentChanges() {
                const { editingAppointment } = this.stateManager.state.modals;
                if (!editingAppointment) return;
                const durationInput = document.getElementById('edit-duration-input');
                const startInput = document.getElementById('edit-start-time-input');
                const newDuration = parseInt(durationInput.value, 10);
                const newStart = startInput.value;
                if (!SecurityUtils.validateDuration(newDuration) || !SecurityUtils.validateTimeString(newStart)) { NotificationSystem.show('Invalid duration or start time.', 'error'); return; }
                const appointments = this.stateManager.state.appointments.map(appt => appt.id === editingAppointment.id ? { ...appt, start: newStart, duration: newDuration } : appt);
                this.stateManager.setState({ appointments });
                this.closeEditModal();
                NotificationSystem.show('Appointment updated!', 'success');
            }
            addPatient() {
                const input = document.getElementById('patient-duration-input');
                if (!input || !input.value) return;
                this.app.addPatientToQueue(parseInt(input.value, 10));
                input.value = '';
            }
            addBreak() {
                const labelInput = document.getElementById('new-break-label');
                const startInput = document.getElementById('new-break-start');
                const endInput = document.getElementById('new-break-end');
                const newBreak = { id: `break-${Date.now()}`, label: SecurityUtils.sanitizeInput(labelInput.value, 'label') || 'New Break', start: startInput.value || '12:00', end: endInput.value || '12:30' };
                const errors = ValidationManager.validateBreakOrTask(newBreak);
                if (errors.length > 0) { NotificationSystem.show(errors.join(', '), 'error'); return; }
                this.stateManager.updateSettings('breaks', [...this.stateManager.state.settings.breaks, newBreak]);
                labelInput.value = ''; startInput.value = ''; endInput.value = '';
            }
            deleteBreak(id) {
                this.stateManager.updateSettings('breaks', this.stateManager.state.settings.breaks.filter(b => b.id !== id));
            }
            addTask() {
                const labelInput = document.getElementById('new-task-label');
                const startInput = document.getElementById('new-task-start');
                const endInput = document.getElementById('new-task-end');
                const typeInput = document.getElementById('new-task-type');
                const newTask = { id: `task-${Date.now()}`, label: SecurityUtils.sanitizeInput(labelInput.value, 'label') || 'New Task', start: startInput.value || '15:00', end: endInput.value || '15:30', type: typeInput.value };
                const errors = ValidationManager.validateBreakOrTask(newTask);
                if (errors.length > 0) { NotificationSystem.show(errors.join(', '), 'error'); return; }
                this.stateManager.updateSettings('otherTasks', [...this.stateManager.state.settings.otherTasks, newTask]);
                labelInput.value = ''; startInput.value = ''; endInput.value = '';
            }
            deleteTask(id) {
                this.stateManager.updateSettings('otherTasks', this.stateManager.state.settings.otherTasks.filter(t => t.id !== id));
            }
            toggleAppointmentComplete(id) {
                this.stateManager.setState({ appointments: this.stateManager.state.appointments.map(appt => appt.id === id ? { ...appt, completed: !appt.completed } : appt) });
            }
            deleteAppointment(id) {
                this.stateManager.setState({ appointments: this.stateManager.state.appointments.filter(appt => appt.id !== id) });
                NotificationSystem.show('Appointment removed.', 'info');
            }
            handleEditModalInput(e) {
                const startInput = document.getElementById('edit-start-time-input');
                const durationInput = document.getElementById('edit-duration-input');
                const endInput = document.getElementById('edit-end-time-input');
                if (!startInput || !durationInput || !endInput) return;
                const startMins = TimeUtils.timeStringToMinutes(startInput.value);
                if (e.target.id === 'edit-start-time-input' || e.target.id === 'edit-duration-input') {
                    const duration = parseInt(durationInput.value, 10);
                    if (!isNaN(duration) && duration > 0) {
                        const endMins = startMins + duration;
                        endInput.value = TimeUtils.minutesTo24hTime(endMins);
                    }
                } else if (e.target.id === 'edit-end-time-input') {
                    const endMins = TimeUtils.timeStringToMinutes(endInput.value);
                    if (endMins > startMins) {
                        const newDuration = endMins - startMins;
                        durationInput.value = newDuration;
                    }
                }
            }
            handleInput(e) {
                if (e.target.closest('#modal-container')) { this.handleEditModalInput(e); }
                if (e.target.classList.contains('validated-input')) { this.validateInput(e.target); }
            }
            handleChange(e) { if (e.target.classList.contains('setting-input')) { this.handleSettingChange(e.target); } }
            handleKeydown(e) {
                if (e.key === 'Enter') {
                    if (e.target.id === 'patient-duration-input') { e.preventDefault(); this.addPatient(); }
                }
            }
            handleDragStart(e) {
                const patientItem = e.target.closest('.patient-item');
                if (patientItem) {
                    // IMPROVEMENT: Store element reference in state to avoid re-querying
                    this.stateManager.setState({ dragState: { draggedPatientId: patientItem.dataset.patientId, draggedElement: patientItem, dropPosition: null, hasConflict: false } }, false);
                    e.dataTransfer.effectAllowed = 'move';
                    setTimeout(() => patientItem.classList.add('dragging'), 0);
                }
            }
            handleDragEnd(e) {
                // IMPROVEMENT: Use element reference from state
                const { draggedElement } = this.stateManager.state.dragState;
                if (draggedElement) {
                    draggedElement.classList.remove('dragging');
                }
                this.stateManager.setState({ dragState: { draggedPatientId: null, draggedElement: null, dropPosition: null, hasConflict: false } }, false);
                this.hideDropIndicator();
            }
            handleDragOver(e) {
                if (!this.stateManager.state.dragState.draggedPatientId) return;
                e.preventDefault();
                this.debouncedDragHandler(e);
            }
            handleDragOverDebounced(e) {
                const { draggedPatientId } = this.stateManager.state.dragState;
                const timeline = e.target.closest('.timeline-scroll-container');
                if (!timeline || !draggedPatientId) return;
                const rect = timeline.getBoundingClientRect();
                const offsetY = e.clientY - rect.top + timeline.scrollTop;
                const dayStartMins = TimeUtils.timeStringToMinutes(this.stateManager.state.settings.workDay.startTime);
                const dropMins = dayStartMins + (offsetY / Constants.PIXELS_PER_HOUR) * 60;
                const patient = this.stateManager.state.patientQueue.find(p => p.id === draggedPatientId);
                if (!patient) return;
                const conflict = ConflictDetector.checkForConflicts(dropMins, patient.duration, this.stateManager.state.appointments, this.stateManager.state.settings.breaks, this.stateManager.state.settings.otherTasks, this.stateManager.state.settings.transitionTime);
                this.showDropIndicator(offsetY, timeline, conflict.hasConflict);
                this.stateManager.setState({ dragState: { ...this.stateManager.state.dragState, dropPosition: dropMins, hasConflict: conflict.hasConflict } }, false);
            }
            handleDragLeave(e) {
                const timeline = e.target.closest('.timeline-scroll-container');
                if (timeline && !timeline.contains(e.relatedTarget)) { this.hideDropIndicator(); }
            }
            handleDrop(e) {
                e.preventDefault();
                const { draggedPatientId, dropPosition, hasConflict } = this.stateManager.state.dragState;
                if (!draggedPatientId || dropPosition === null || hasConflict) {
                    if (hasConflict) NotificationSystem.show('Cannot schedule due to a conflict.', 'error');
                    this.hideDropIndicator();
                    return;
                }
                const patient = this.stateManager.state.patientQueue.find(p => p.id === draggedPatientId);
                const newAppointment = { ...patient, id: `appt-${Date.now()}-${patient.id}`, start: TimeUtils.minutesTo24hTime(dropPosition), completed: false };
                this.stateManager.setState({
                    appointments: [...this.stateManager.state.appointments, newAppointment],
                    patientQueue: this.stateManager.state.patientQueue.filter(p => p.id !== draggedPatientId)
                });
                NotificationSystem.show(`Scheduled ${patient.name}.`, 'success');
                this.hideDropIndicator();
            }
            showDropIndicator(offsetY, timeline, hasConflict) {
                let indicator = timeline.querySelector('.drop-line-indicator');
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.className = 'drop-line-indicator';
                    timeline.appendChild(indicator);
                }
                // REFACTORED: Use modifier classes for state
                indicator.classList.toggle('is-valid', !hasConflict);
                indicator.classList.toggle('is-conflict', hasConflict);
                indicator.style.top = `${offsetY}px`;
                indicator.style.display = 'block';
            }
            hideDropIndicator() {
                const indicator = document.querySelector('.drop-line-indicator');
                if(indicator) indicator.style.display = 'none';
            }
            validateInput(input) {
                const { validateType: type, value } = input.dataset;
                let isValid = true;
                switch (type) {
                    case 'duration': isValid = SecurityUtils.validateDuration(input.value); break;
                    case 'time': isValid = SecurityUtils.validateTimeString(input.value); break;
                    case 'label': isValid = SecurityUtils.validateLabel(input.value); break;
                }
                input.classList.toggle('success-border', isValid);
                input.classList.toggle('error-border', !isValid);
                setTimeout(() => input.classList.remove('success-border', 'error-border'), 2000);
            }
            handleSettingChange(input) {
                const { path, type } = input.dataset;
                let value = type === 'number' ? parseInt(input.value, 10) || 0 : SecurityUtils.sanitizeInput(input.value, type);
                if (type === 'time' && !SecurityUtils.validateTimeString(value)) { NotificationSystem.show('Invalid time format', 'error'); return; }
                this.stateManager.updateSettings(path, value);
            }
        }

        // === RENDERER (REFACTORED for Granular DOM Updates) ===
        // NOTE: This renderer has been significantly refactored to avoid using innerHTML for updates.
        // It now performs more targeted DOM manipulations for better performance and to preserve
        // DOM state (like input focus). This is a manual implementation of a "virtual DOM" diffing strategy.
        class AppRenderer {
            constructor() {
                this.root = document.getElementById('app-root');
                this.cache = {};
            }
            initialRender() {
                this.root.innerHTML = `
                    <div class="max-w-full mx-auto px-4 sm:px-6 lg:px-8 py-4 sm:py-6 bg-gray-900 text-gray-300 min-h-screen font-sans printable-area">
                        <div id="notification-container" class="no-print"></div>
                        <div id="modal-container" class="no-print"></div>

                        <header id="header-container" class="no-print flex flex-wrap items-center justify-between mb-6 gap-4" role="banner">
                            <div class="flex items-center gap-3">
                                <span class="p-2 bg-blue-500/20 text-blue-300 rounded-lg">${getIcon('BrainCircuit', 28)}</span>
                                <h1 class="text-2xl sm:text-3xl font-bold text-gray-100">Therapy Scheduler</h1>
                            </div>
                            <div class="flex items-center gap-2">
                                <button data-action="${Constants.ACTIONS.SAVE}" class="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors shadow-md text-sm font-semibold">
                                    ${getIcon('Save', 16)}<span>Save</span>
                                </button>
                                <button data-action="${Constants.ACTIONS.PRINT}" class="flex items-center gap-2 px-4 py-2 bg-gray-700 text-white rounded-md hover:bg-gray-600 transition-colors shadow-md text-sm font-semibold">
                                    ${getIcon('Printer', 16)}<span>Print</span>
                                </button>
                                 <button data-action="${Constants.ACTIONS.CLEAR_DAY}" class="flex items-center gap-2 px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors shadow-md text-sm font-semibold">
                                    ${getIcon('Trash2', 16)}<span>Clear Day</span>
                                </button>
                            </div>
                        </header>

                        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                            <div class="lg:col-span-1 space-y-6 no-print" role="form">
                                <div id="patient-queue-container"></div>
                                <div id="settings-panel-container"></div>
                            </div>
                            <main class="lg:col-span-2 space-y-6" aria-label="Schedule">
                                <div id="day-summary-container"></div>
                                <div id="schedule-timeline-container"></div>
                            </main>
                        </div>
                    </div>`;

                // Cache top-level containers
                this.cache.modals = document.getElementById('modal-container');
                this.cache.patientQueue = document.getElementById('patient-queue-container');
                this.cache.settings = document.getElementById('settings-panel-container');
                this.cache.summary = document.getElementById('day-summary-container');
                this.cache.timeline = document.getElementById('schedule-timeline-container');

                // Perform one-time render of static-like components
                this.cache.patientQueue.innerHTML = this._renderPatientQueueContainer();
                this.cache.settings.innerHTML = this._renderSettingsPanelContainer();
                this.cache.summary.innerHTML = this._renderDaySummaryContainer();
                this.cache.timeline.innerHTML = this._renderScheduleTimelineContainer();
            }

            update(state) {
                // Granular updates instead of innerHTML replacement
                this._updateModals(state);
                this._updatePatientQueue(state);
                this._updateSettingsPanel(state);
                if (state.schedule) {
                    this._updateDaySummary(state);
                    this._updateScheduleTimeline(state);
                }
            }

            _updateModals(state) {
                // Modals are ephemeral; replacing innerHTML is acceptable and simpler here.
                if (!state.modals.clearDay && !state.modals.editAppointment) {
                    this.cache.modals.innerHTML = '';
                    return;
                }
                this.cache.modals.innerHTML = this._getModalContent(state);
            }

            _updatePatientQueue(state) {
                const listEl = document.getElementById('patient-list');
                const emptyMsgEl = document.getElementById('patient-queue-empty-msg');
                const autoScheduleBtn = document.querySelector('[data-action="auto-schedule"]');

                if (state.patientQueue.length === 0) {
                    listEl.innerHTML = '';
                    emptyMsgEl.style.display = 'block';
                    autoScheduleBtn.disabled = true;
                } else {
                    emptyMsgEl.style.display = 'none';
                    autoScheduleBtn.disabled = false;
                    this._diffAndUpdateList(listEl, state.patientQueue, this._getPatientQueueItemHTML);
                }
            }

            _updateSettingsPanel(state) {
                // Update simple input values
                document.querySelector('[data-path="workDay.startTime"]').value = state.settings.workDay.startTime;
                document.querySelector('[data-path="productivityTarget"]').value = state.settings.productivityTarget;
                document.querySelector('[data-path="workdayDurationHours"]').value = state.settings.workdayDurationHours;
                document.querySelector('[data-path="transitionTime"]').value = state.settings.transitionTime;
                document.querySelector('[data-path="setupTime"]').value = state.settings.setupTime;

                // Diff-update break and task lists
                this._diffAndUpdateList(document.getElementById('breaks-list'), state.settings.breaks, this._getBreakItemHTML);
                this._diffAndUpdateList(document.getElementById('tasks-list'), state.settings.otherTasks, this._getTaskItemHTML);

                // Toggle admin settings visibility
                const adminContent = document.getElementById('admin-settings-content');
                const chevron = document.querySelector('[data-action="toggle-admin-settings"] span');
                if (state.ui.isAdminSettingsOpen) {
                    adminContent.classList.remove('hidden');
                    chevron.classList.add('rotate-180');
                } else {
                    adminContent.classList.add('hidden');
                    chevron.classList.remove('rotate-180');
                }
            }

            _updateDaySummary(state) {
                const { schedule } = state;
                if (!schedule) return;

                const productivityColor = schedule.productivity >= state.settings.productivityTarget ? 'text-green-400' : (schedule.productivity > 0 ? 'text-yellow-400' : 'text-gray-400');

                const productivityEl = document.getElementById('summary-productivity');
                productivityEl.textContent = `${schedule.productivity}%`;
                productivityEl.className = `text-2xl font-bold ${productivityColor}`;

                document.getElementById('summary-schedule-end').textContent = schedule.meetsTarget ? TimeUtils.minutesToTime(schedule.lastEndMins) : 'N/A';
                document.getElementById('summary-target-clock-out').textContent = schedule.meetsTarget ? TimeUtils.minutesToTime(schedule.projectedClockOutMins) : 'N/A';
                document.getElementById('summary-billable').textContent = schedule.totalBillableTime;
                document.getElementById('summary-unavailable').textContent = schedule.timeUnavailable;

                const suggestionsHTML = schedule.suggestions.map(s => `<p class="flex items-start gap-2">${getIcon('AlertCircle', 16, 'mt-0.5 flex-shrink-0')}<span>${s}</span></p>`).join('');
                document.getElementById('summary-suggestions').innerHTML = suggestionsHTML;
            }

            _updateScheduleTimeline(state) {
                const container = document.getElementById('schedule-timeline-content');
                const emptyMsg = document.getElementById('timeline-empty-msg');

                const hasItems = state.appointments.length > 0 || state.settings.breaks.length > 0 || state.settings.otherTasks.length > 0;

                if (!hasItems) {
                    container.innerHTML = ''; // Clear items
                    emptyMsg.style.display = 'flex';
                    return;
                }

                emptyMsg.style.display = 'none';

                const dayStartMins = TimeUtils.timeStringToMinutes(state.settings.workDay.startTime);
                const scheduledEndMins = state.schedule.lastEndMins;
                const configuredEndMins = dayStartMins + (state.settings.workdayDurationHours * 60);

                // The timeline should be long enough for the longer of the two, plus a buffer.
                const timelineEndMins = Math.max(scheduledEndMins, configuredEndMins);
                const timelineDurationMins = Math.max(0, timelineEndMins - dayStartMins);

                // Calculate height based on the dynamic duration. Add a 30 min buffer for padding.
                const timelineContentHeight = ((timelineDurationMins + 30) / 60) * Constants.PIXELS_PER_HOUR;
                container.style.height = `${timelineContentHeight}px`;

                // Update time markers to cover the new dynamic height
                const totalHours = (timelineDurationMins + 30) / 60;
                container.innerHTML = this._renderTimeMarkers(dayStartMins, totalHours);

                // Diff-update timeline items
                const laidOutItems = ScheduleCalculator.calculateAppointmentLayout(state.schedule.timelineItems);
                this._diffAndUpdateTimeline(container, laidOutItems, dayStartMins);
            }

            // --- Diffing and Granular Update Helpers ---

            _diffAndUpdateList(listEl, items, itemHtmlFn) {
                const itemIds = new Set(items.map(p => p.id));
                // Remove items that are no longer in the state
                Array.from(listEl.children).forEach(child => {
                    if (!itemIds.has(child.dataset.id)) {
                        child.remove();
                    }
                });
                // Add or update items
                items.forEach(item => {
                    let itemEl = listEl.querySelector(`[data-id="${item.id}"]`);
                    if (!itemEl) {
                        const div = document.createElement('div');
                        div.innerHTML = itemHtmlFn.call(this, item);
                        listEl.appendChild(div.firstElementChild);
                    } else {
                        // For this app, re-rendering the item on change is simple enough.
                        // A more complex app might update individual properties.
                        itemEl.outerHTML = itemHtmlFn.call(this, item);
                    }
                });
            }

            _diffAndUpdateTimeline(container, items, dayStartMins) {
                const itemIds = new Set(items.map(p => p.id));
                // Remove items no longer in schedule
                container.querySelectorAll('.timeline-item').forEach(child => {
                    if (!itemIds.has(child.dataset.id)) {
                        child.remove();
                    }
                });

                // Add or update items
                items.forEach(item => {
                    const top = ((item.startMins - dayStartMins) / 60) * Constants.PIXELS_PER_HOUR;
                    const height = ((item.endMins - item.startMins) / 60) * Constants.PIXELS_PER_HOUR;
                    if (height <= 0) return;

                    let itemEl = container.querySelector(`[data-id="${item.id}"]`);
                    const html = this._getTimelineItemHTML(item, top, height);

                    if (!itemEl) {
                        const div = document.createElement('div');
                        div.innerHTML = html;
                        container.appendChild(div.firstElementChild);
                    } else {
                        // A simple way to update: replace if content changed.
                        // For maximum performance, you would check each attribute and property.
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = html;
                        if(itemEl.outerHTML !== tempDiv.innerHTML) {
                           itemEl.outerHTML = html;
                        }
                    }
                });
            }

            // --- HTML String Generators for Containers (called once) ---

            _renderPatientQueueContainer() {
                return `
                    <div class="bg-gray-800 rounded-lg shadow-lg p-4 border border-gray-700">
                        <h2 id="patient-queue-heading" class="text-xl font-semibold text-gray-200 mb-4">Patient Queue</h2>
                        <div class="mb-4">
                            <label for="patient-duration-input" class="block text-sm font-medium text-gray-400 mb-1">New Patient Session Duration (min)</label>
                            <div class="flex gap-2">
                                <input id="patient-duration-input" type="number" placeholder="e.g., 60" class="flex-grow w-full bg-gray-900 border border-gray-600 rounded-md px-3 py-2 text-gray-200 focus:ring-2 focus:ring-blue-500 focus:border-blue-500 validated-input" data-validate-type="duration">
                                <button data-action="${Constants.ACTIONS.ADD_PATIENT}" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors font-semibold" aria-label="Add Patient">${getIcon('Plus', 16)}</button>
                            </div>
                        </div>
                        <div class="flex flex-wrap gap-2 mb-4">
                             <button data-action="${Constants.ACTIONS.ADD_PATIENT_PRESET}" data-duration="25" class="text-xs px-3 py-1 bg-yellow-500/80 hover:bg-yellow-500 text-white font-semibold rounded-full transition-colors">25 min</button>
                             <button data-action="${Constants.ACTIONS.ADD_PATIENT_PRESET}" data-duration="30" class="text-xs px-3 py-1 bg-purple-500/80 hover:bg-purple-500 text-white font-semibold rounded-full transition-colors">30 min</button>
                             <button data-action="${Constants.ACTIONS.ADD_PATIENT_PRESET}" data-duration="38" class="text-xs px-3 py-1 bg-green-500/80 hover:bg-green-500 text-white font-semibold rounded-full transition-colors">38 min</button>
                             <button data-action="${Constants.ACTIONS.ADD_PATIENT_PRESET}" data-duration="53" class="text-xs px-3 py-1 bg-blue-500/80 hover:bg-blue-500 text-white font-semibold rounded-full transition-colors">53 min</button>
                        </div>
                        <div id="patient-list" class="space-y-2 max-h-48 overflow-y-auto pr-2" aria-labelledby="patient-queue-heading"></div>
                        <p id="patient-queue-empty-msg" class="text-gray-500 text-center py-4" style="display: none;">Queue is empty</p>
                        <button data-action="${Constants.ACTIONS.AUTO_SCHEDULE}" class="mt-4 w-full flex items-center justify-center gap-2 px-4 py-2 bg-yellow-600 text-white rounded-md hover:bg-yellow-700 transition-colors font-semibold disabled:opacity-50 disabled:cursor-not-allowed">
                           ${getIcon('Zap', 16)} <span>Auto-Schedule All</span>
                        </button>
                    </div>`;
            }

            _renderSettingsPanelContainer() {
                return `
                    <div class="bg-gray-800 rounded-lg shadow-lg p-4 border border-gray-700">
                        <h2 class="text-xl font-semibold text-gray-200 mb-4">Day Settings</h2>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium text-gray-400">Workday Start</label>
                                <input type="time" class="w-full bg-gray-900 border border-gray-600 rounded-md px-3 py-2 text-gray-200 setting-input validated-input" data-path="workDay.startTime" data-type="time" data-validate-type="time">
                            </div>
                        </div>
                        <div class="mt-6">
                            <h3 class="font-semibold text-gray-300 mb-2">Breaks</h3>
                            <div id="breaks-list" class="space-y-2 mb-3"></div>
                            <div class="flex flex-wrap gap-2">
                                <input type="text" id="new-break-label" placeholder="Lunch" class="flex-grow bg-gray-900 border border-gray-600 rounded-md px-2 py-1 text-sm">
                                <input type="time" id="new-break-start" class="bg-gray-900 border border-gray-600 rounded-md px-2 py-1 text-sm">
                                <input type="time" id="new-break-end" class="bg-gray-900 border border-gray-600 rounded-md px-2 py-1 text-sm">
                                <button data-action="${Constants.ACTIONS.ADD_BREAK}" class="p-2 bg-blue-600 text-white rounded-md hover:bg-blue-700" aria-label="Add Break">${getIcon('Plus', 16)}</button>
                            </div>
                        </div>
                        <div class="mt-6">
                            <h3 class="font-semibold text-gray-300 mb-2">Other Tasks</h3>
                            <div id="tasks-list" class="space-y-2 mb-3"></div>
                            <div class="flex flex-wrap gap-2">
                                <input type="text" id="new-task-label" placeholder="Documentation" class="flex-grow bg-gray-900 border border-gray-600 rounded-md px-2 py-1 text-sm">
                                <input type="time" id="new-task-start" class="bg-gray-900 border border-gray-600 rounded-md px-2 py-1 text-sm">
                                <input type="time" id="new-task-end" class="bg-gray-900 border border-gray-600 rounded-md px-2 py-1 text-sm">
                                <select id="new-task-type" class="bg-gray-900 border border-gray-600 rounded-md px-2 py-1 text-sm">
                                    <option value="billable">Billable</option>
                                    <option value="non-billable">Non-Billable</option>
                                </select>
                                <button data-action="${Constants.ACTIONS.ADD_TASK}" class="p-2 bg-blue-600 text-white rounded-md hover:bg-blue-700" aria-label="Add Task">${getIcon('Plus', 16)}</button>
                            </div>
                        </div>
                        <div class="mt-6 pt-4 border-t border-gray-700">
                            <button data-action="${Constants.ACTIONS.TOGGLE_ADMIN_SETTINGS}" class="w-full flex justify-between items-center text-left font-semibold text-gray-300 mb-2">
                                <span>Admin Settings</span>
                                <span class="transition-transform transform">${getIcon('ChevronDown')}</span>
                            </button>
                            <div id="admin-settings-content" class="hidden">
                                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mt-4 animate-fade-in-down">
                                    <div>
                                        <label class="block text-sm font-medium text-gray-400">Productivity Target (%)</label>
                                        <input type="number" class="w-full bg-gray-900 border border-gray-600 rounded-md px-3 py-2 text-gray-200 setting-input" data-path="productivityTarget" data-type="number" min="0" max="100">
                                    </div>
                                    <div>
                                        <label class="block text-sm font-medium text-gray-400">Workday Hours</label>
                                        <input type="number" class="w-full bg-gray-900 border border-gray-600 rounded-md px-3 py-2 text-gray-200 setting-input" data-path="workdayDurationHours" data-type="number" min="1" max="${Constants.MAX_WORKDAY_HOURS}">
                                    </div>
                                    <div>
                                        <label class="block text-sm font-medium text-gray-400">Transition Time (min)</label>
                                        <input type="number" class="w-full bg-gray-900 border border-gray-600 rounded-md px-3 py-2 text-gray-200 setting-input" data-path="transitionTime" data-type="number">
                                    </div>
                                    <div class="sm:col-span-2">
                                        <label class="block text-sm font-medium text-gray-400">Setup Time (min)</label>
                                        <input type="number" class="w-full bg-gray-900 border border-gray-600 rounded-md px-3 py-2 text-gray-200 setting-input" data-path="setupTime" data-type="number">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>`;
            }

            _renderDaySummaryContainer() {
                return `
                         <section class="bg-gray-800 rounded-lg shadow-lg p-4 border border-gray-700" aria-labelledby="summary-heading" aria-live="polite">
                            <h2 id="summary-heading" class="text-xl font-semibold text-gray-200 mb-4">Day Summary</h2>
                              <div class="grid grid-cols-2 md:grid-cols-3 gap-y-4 gap-x-2 text-center mb-4">
                                  <div>
                                      <div id="summary-productivity" class="text-2xl font-bold">0%</div>
                                      <div class="text-sm text-gray-400">Productivity</div>
                                  </div>
                                  <div>
                                      <div id="summary-schedule-end" class="text-2xl font-bold text-gray-200">N/A</div>
                                      <div class="text-sm text-gray-400">Schedule End</div>
                                  </div>
                                   <div>
                                      <div id="summary-target-clock-out" class="text-2xl font-bold text-blue-400">N/A</div>
                                      <div class="text-sm text-gray-400">Target Clock-Out</div>
                                  </div>
                                  <div class="col-span-1">
                                      <div id="summary-billable" class="text-2xl font-bold text-green-400">0</div>
                                      <div class="text-sm text-gray-400">Billable Mins</div>
                                  </div>
                                  <div class="col-span-2">
                                      <div id="summary-unavailable" class="text-2xl font-bold text-yellow-400">0</div>
                                      <div class="text-sm text-gray-400">Unavailable Mins</div>
                                  </div>
                              </div>
                              <div id="summary-suggestions" class="bg-gray-900/50 rounded-lg p-3 text-sm text-gray-400 space-y-2">
                              </div>
                         </section>`;
            }

            _renderScheduleTimelineContainer() {
                return `
                    <section class="bg-gray-800 rounded-lg shadow-lg p-4 border border-gray-700" aria-labelledby="schedule-heading">
                        <h2 id="schedule-heading" class="text-xl font-semibold text-gray-200 mb-4">Visual Schedule</h2>
                        <div class="timeline-scroll-container bg-gray-900/50 pl-10 sm:pl-14 py-2">
                            <div id="timeline-empty-msg" class="flex items-center justify-center text-center p-8 min-h-[400px]">
                                 <div>
                                    <div class="text-5xl mb-4 opacity-50">${getIcon('Calendar', 64)}</div>
                                    <h3 class="text-xl font-semibold text-gray-400">Your day is clear!</h3>
                                    <p class="text-gray-500">Add patients to the queue and drag them here to get started.</p>
                                 </div>
                            </div>
                            <div id="schedule-timeline-content" class="relative"></div>
                        </div>
                    </section>`;
            }


            // --- HTML String Generators for Individual Items (called during updates) ---

            _getModalContent(state) {
                  let modalContent = '';
                  if (state.modals.clearDay) {
                          modalContent = `
                              <div class="bg-gray-800 rounded-lg p-6 w-full max-w-md mx-auto border border-gray-700 shadow-xl animate-fade-in-down">
                                  <div class="flex items-center gap-3 mb-4">
                                     <span class="text-red-400">${getIcon('AlertCircle', 24)}</span>
                                     <h3 id="clear-day-heading" class="text-xl font-semibold text-gray-100">Confirm Clear Schedule</h3>
                                  </div>
                                  <p class="text-gray-400 mb-6">Are you sure you want to delete all appointments and clear the patient queue? This action cannot be undone.</p>
                                  <div class="flex justify-end gap-3">
                                      <button data-action="${Constants.ACTIONS.CANCEL_CLEAR}" class="px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-500 transition-colors font-semibold">Cancel</button>
                                      <button data-action="${Constants.ACTIONS.CONFIRM_CLEAR}" class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors font-semibold">Yes, Clear It</button>
                                  </div>
                              </div>`;
                  } else if (state.modals.editAppointment && state.modals.editingAppointment) {
                      const appt = state.modals.editingAppointment;
                      modalContent = `
                           <div class="bg-gray-800 rounded-lg p-6 w-full max-w-md mx-auto border border-gray-700 shadow-xl animate-fade-in-down">
                               <div class="flex items-center justify-between mb-4">
                                   <h3 id="edit-appt-heading" class="text-xl font-semibold text-gray-100">Edit Appointment: ${SecurityUtils.sanitizeHTML(appt.name)}</h3>
                                   <button data-action="${Constants.ACTIONS.CANCEL_EDIT}" class="p-1 rounded-full hover:bg-white/10" aria-label="Close edit modal">${getIcon('X', 20)}</button>
                               </div>
                               <div class="space-y-4">
                                   <div class="grid grid-cols-2 gap-4">
                                       <div>
                                           <label for="edit-start-time-input" class="block text-sm font-medium text-gray-400 mb-1">Start Time</label>
                                           <input type="time" id="edit-start-time-input" value="${appt.start}" class="w-full bg-gray-900 border border-gray-600 rounded-md px-3 py-2 text-gray-200 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                       </div>
                                       <div>
                                           <label for="edit-end-time-input" class="block text-sm font-medium text-gray-400 mb-1">End Time</label>
                                           <input type="time" id="edit-end-time-input" value="${TimeUtils.minutesTo24hTime(TimeUtils.timeStringToMinutes(appt.start) + appt.duration)}" class="w-full bg-gray-900 border border-gray-600 rounded-md px-3 py-2 text-gray-200 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                       </div>
                                   </div>
                                   <div>
                                       <label for="edit-duration-input" class="block text-sm font-medium text-gray-400 mb-1">Duration (minutes)</label>
                                       <input type="number" id="edit-duration-input" value="${appt.duration}" class="w-full bg-gray-900 border border-gray-600 rounded-md px-3 py-2 text-gray-200 focus:ring-2 focus:ring-blue-500 focus:border-blue-500">
                                   </div>
                               </div>
                               <div class="flex justify-end gap-3 mt-6">
                                   <button data-action="${Constants.ACTIONS.CANCEL_EDIT}" class="px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-500 transition-colors font-semibold">Cancel</button>
                                   <button data-action="${Constants.ACTIONS.SAVE_EDIT}" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors font-semibold">Save Changes</button>
                               </div>
                           </div>`;
                  }
                  // ACCESSIBILITY: Add modal roles
                  return `<div class="fixed inset-0 bg-black/60 z-40 flex items-center justify-center p-4" role="dialog" aria-modal="true" aria-labelledby="${state.modals.clearDay ? 'clear-day-heading' : 'edit-appt-heading'}">${modalContent}</div>`;
            }

            _getPatientQueueItemHTML(p) {
                return `
                    <div class="patient-item flex items-center justify-between p-2 rounded-md cursor-grab border ${this._getAppointmentColor(p.duration)}" draggable="true" data-id="${p.id}" data-patient-id="${p.id}">
                        <strong class="font-bold">${SecurityUtils.sanitizeHTML(p.name)} - ${p.duration} min</strong>
                        <button data-action="${Constants.ACTIONS.REMOVE_PATIENT}" data-patient-id="${p.id}" class="p-1 rounded-full text-gray-300 hover:bg-black/20 hover:text-white" aria-label="Remove ${SecurityUtils.sanitizeHTML(p.name)} from queue">${getIcon('Trash2', 14)}</button>
                    </div>`;
            }

            _getBreakItemHTML(b) {
                return `
                    <div class="flex items-center justify-between gap-2 bg-gray-700/50 p-2 rounded-md text-sm" data-id="${b.id}">
                        <span>${getIcon('Coffee', 16)} ${SecurityUtils.sanitizeHTML(b.label)} (${b.start} - ${b.end})</span>
                        <button data-action="${Constants.ACTIONS.DELETE_BREAK}" data-id="${b.id}" class="p-1 rounded-full text-gray-400 hover:bg-red-500/20 hover:text-red-400" aria-label="Delete break: ${SecurityUtils.sanitizeHTML(b.label)}">${getIcon('Trash2', 14)}</button>
                    </div>`;
            }

            _renderTimeMarkers(dayStartMins, totalHours) {
                let markers = '';
                const totalMinutes = totalHours * 60;
                for (let i = 0; i <= totalMinutes; i += 30) {
                    const top = (i / 60) * Constants.PIXELS_PER_HOUR;
                    const isHour = i % 60 === 0;
                    markers += `
                        <div class="absolute w-full pointer-events-none" style="top: ${top}px; z-index: 0;">
                            <div class="absolute -left-10 sm:-left-14 top-[-0.75em] text-xs ${isHour ? 'text-gray-300 font-semibold' : 'text-gray-500'}">${TimeUtils.minutesToTime(dayStartMins + i)}</div>
                            <div class="border-t ${isHour ? 'border-gray-600' : 'border-gray-700 border-dashed'}"></div>
                        </div>`;
                }
                return markers;
            }

            _getTimelineItemHTML(item, top, height) {
                 switch (item.type) {
                     case 'appointment': return this._getAppointmentItemHTML(item, top, height);
                     case 'break': return this._getTaskItemHTMLonTimeline(item, top, height, 'Coffee');
                     case 'billable': return this._getTaskItemHTMLonTimeline(item, top, height, 'Briefcase', 'bg-green-500/10 border-green-500/50 text-green-300');
                     case 'non-billable': return this._getTaskItemHTMLonTimeline(item, top, height, 'Briefcase', 'bg-yellow-500/10 border-yellow-500/50 text-yellow-300');
                     case 'gap': return this._getGapItemHTML(item, top, height);
                     default: return '';
                 }
            }

            _getAppointmentItemHTML(item, top, height) {
                const { lane, totalLanes } = item.layout;
                const itemWidth = totalLanes > 1 ? (95 / totalLanes) - 0.5 : 95;
                const itemLeft = 2.5 + (lane * (95 / totalLanes));
                const fontSize = height < Constants.APPOINTMENT_SMALL_FONT_THRESHOLD_PX ? 'text-xs' : 'text-sm';
                const timeDetailsVisibility = height < Constants.APPOINTMENT_HIDE_TIME_THRESHOLD_PX ? 'hidden' : 'block';
                const colorClass = this._getAppointmentColor(item.duration);
                return `
                    <div class="timeline-item absolute" style="top: ${top}px; height: ${height}px; width: ${itemWidth}%; left: ${itemLeft}%; z-index: ${10 + lane};" data-id="${item.id}">
                        <div class="timeline-appointment-item relative group p-2 rounded-md h-full w-full border flex flex-col justify-between ${colorClass} ${item.completed ? 'opacity-60' : ''}" tabindex="0">
                             <div class="flex-grow flex flex-col justify-center ${fontSize} cursor-pointer" data-action="${Constants.ACTIONS.TOGGLE_COMPLETE}" data-id="${item.id}">
                                 <div class="flex justify-between items-start">
                                     <strong class="font-bold ${item.completed ? 'line-through' : ''}">${SecurityUtils.sanitizeHTML(item.name)}</strong>
                                     <span class="font-semibold flex-shrink-0 pl-2 ${item.completed ? 'line-through' : ''}">${item.duration} min</span>
                                 </div>
                                 <div class="text-xs opacity-80 ${timeDetailsVisibility} ${item.completed ? 'line-through' : ''}">${TimeUtils.minutesToTime(item.startMins)} - ${TimeUtils.minutesToTime(item.endMins)}</div>
                             </div>
                             <div class="appointment-actions absolute top-1 right-1 flex gap-1">
                                 <button data-action="${Constants.ACTIONS.EDIT_APPOINTMENT}" data-id="${item.id}" class="p-1 rounded-full bg-black/20 hover:bg-black/40" aria-label="Edit appointment">${getIcon('Edit',14)}</button>
                                 <button data-action="${Constants.ACTIONS.DELETE_APPOINTMENT}" data-id="${item.id}" class="p-1 rounded-full bg-black/20 hover:bg-black/40" aria-label="Delete appointment">${getIcon('Trash2',14)}</button>
                             </div>
                             ${item.completed ? `<div class="absolute inset-0 bg-black/30 flex items-center justify-center rounded-md pointer-events-none">${getIcon('CheckCircle', 32)}</div>` : ''}
                        </div>
                    </div>`;
            }

            _getTaskItemHTMLonTimeline(item, top, height, iconName, colorClass = 'bg-purple-500/10 border-purple-500/50 text-purple-300') {
                 return `
                        <div class="timeline-item absolute w-[95%] left-[2.5%]" style="top: ${top}px; height: ${height}px; z-index: 5;" data-id="${item.id}">
                            <div class="h-full rounded-md p-2 flex items-center text-sm ${colorClass} border">
                               ${getIcon(iconName, 16)}
                               <span class="ml-2 font-semibold">${SecurityUtils.sanitizeHTML(item.label)}</span>
                            </div>
                        </div>`;
            }

            _getGapItemHTML(item, top, height) {
                 if (height < 20) return ''; // Don't render very small gaps
                 return `
                        <div class="timeline-item absolute w-[95%] left-[2.5%]" style="top: ${top}px; height: ${height}px; z-index: 1;" data-id="${item.id}">
                            <div class="h-full rounded-md border-2 border-dashed border-gray-700/50 flex items-center justify-center text-gray-600 text-xs">
                                <span>${item.duration} min gap</span>
                            </div>
                        </div>`;
            }

            _getAppointmentColor(duration) {
                if (duration >= 90) return 'bg-red-500/20 border-red-500/50 text-red-300';
                if (duration >= 53) return 'bg-blue-500/20 border-blue-500/50 text-blue-300';
                if (duration >= 38) return 'bg-green-500/20 border-green-500/50 text-green-300';
                if (duration >= 30) return 'bg-purple-500/20 border-purple-500/50 text-purple-300';
                return 'bg-yellow-500/20 border-yellow-500/50 text-yellow-300';
            }
        }

        // === APPLICATION INITIALIZATION ===
        document.addEventListener('DOMContentLoaded', () => {
            try { new TherapySchedulerApp(); }
            catch (error) { ErrorHandler.logError(error, 'AppInitialization'); document.body.innerHTML = `<div class="min-h-screen bg-gray-900 flex items-center justify-center text-center text-gray-300"><h1 class="text-2xl font-bold">Application Error. Please refresh.</h1></div>`; }
        });
    </script>
</body>
</html>