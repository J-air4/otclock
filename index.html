<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Therapy Scheduler UI Redesign</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        @media print {
            body { -webkit-print-color-adjust: exact !important; print-color-adjust: exact !important; }
            .printable-area, .printable-area * { visibility: visible; background: white !important; color: black !important; }
            .printable-area { position: absolute; left: 0; top: 0; width: 100%; }
            .no-print { display: none; }
        }
        @keyframes fade-in-down {
            0% { opacity: 0; transform: translateY(-10px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-in-down { animation: fade-in-down 0.3s ease-out forwards; }
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type=number] { -moz-appearance: textfield; }

        .timeline-appointment-item {
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .timeline-appointment-item:hover {
            z-index: 20;
            transform: scale(1.02);
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-300">
    <div id="app-root"></div>

    <script type="module">
        // === SECURITY & VALIDATION MODULE ===
        class SecurityUtils {
            static sanitizeHTML(str) {
                const div = document.createElement('div');
                div.textContent = String(str ?? '');
                return div.innerHTML;
            }
            static validateTimeString(timeStr) {
                if (!timeStr || typeof timeStr !== 'string') return false;
                const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
                return timeRegex.test(timeStr);
            }
            static validateDuration(duration) {
                const num = parseInt(duration, 10);
                return !isNaN(num) && num >= Constants.MINIMUM_SCHEDULABLE_DURATION && num <= Constants.MAXIMUM_SCHEDULABLE_DURATION;
            }
            static validateLabel(label) {
                if (!label || typeof label !== 'string') return false;
                return label.trim().length > 0 && label.length <= Constants.MAX_LABEL_LENGTH;
            }
            static sanitizeInput(input, type = 'text') {
                if (input === null || input === undefined) return '';
                switch (type) {
                    case 'number':
                        const num = parseInt(input, 10);
                        return isNaN(num) ? 0 : Math.max(0, num);
                    case 'time':
                        return this.validateTimeString(input) ? input : '00:00';
                    case 'label':
                        return String(input).trim().substring(0, Constants.MAX_LABEL_LENGTH);
                    default:
                        return this.sanitizeHTML(input);
                }
            }
        }

        // === ERROR HANDLING MODULE ===
        class ErrorHandler {
            static logError(error, context = '') {
                console.error(`[TherapySchedulerApp] ${context}:`, error);
            }
            static showUserError(message) {
                NotificationSystem.show(message, 'error');
            }
            static handleStorageError(operation, fallback = null) {
                try {
                    return operation();
                } catch (error) {
                    this.logError(error, 'Storage');
                    this.showUserError('Storage operation failed. Your changes may not be saved.');
                    return fallback;
                }
            }
        }

        // === CONSTANTS ===
        const Constants = {
            MINIMUM_SCHEDULABLE_DURATION: 5,
            MAXIMUM_SCHEDULABLE_DURATION: 480,
            PIXELS_PER_HOUR: 120,
            MAX_WORKDAY_HOURS: 16,
            MAX_LABEL_LENGTH: 100,
            NOTIFICATION_TIMEOUT_MS: 5000,
            LATE_WORK_THRESHOLD_HOUR: 19, // 7 PM
            PATIENT_PRESET_DURATIONS: [38, 30, 53, 25],
            DEFAULT_SETTINGS: {
                workDay: { startTime: '08:30' },
                breaks: [],
                otherTasks: [],
                transitionTime: 2,
                setupTime: 5,
                productivityTarget: 93,
                workdayDurationHours: 12
            },
            DEFAULT_END_TIME: '17:00',
            TIMELINE_LAYOUT: {
                BASE_WIDTH_PERCENT: 90,
                BASE_LEFT_PERCENT: 5,
                OVERLAP_OFFSET_PERCENT: 0.25,
                OVERLAP_GAP_PERCENT: 0.5,
                BASE_Z_INDEX: 10,
                ITEM_MIN_HEIGHT_PX: 1
            },
            APPOINTMENT_COLOR_THRESHOLDS: {
                SHORT: 25,
                MEDIUM: 35,
                LONG: 45,
            },
            TIME: {
                MINUTES_IN_HOUR: 60,
                HOURS_IN_DAY: 24,
                HOURS_AM_PM: 12,
            },
            ACTIONS: {
                SAVE: 'save', PRINT: 'print', CLEAR_DAY: 'clear-day', CONFIRM_CLEAR: 'confirm-clear', CANCEL_CLEAR: 'cancel-clear',
                ADD_PATIENT: 'add-patient', ADD_PATIENT_PRESET: 'add-patient-preset', REMOVE_PATIENT: 'remove-patient',
                AUTO_SCHEDULE: 'auto-schedule', EDIT_APPOINTMENT: 'edit-appointment', DELETE_APPOINTMENT: 'delete-appointment',
                TOGGLE_COMPLETE: 'toggle-complete', ADD_BREAK: 'add-break', DELETE_BREAK: 'delete-break', ADD_TASK: 'add-task',
                DELETE_TASK: 'delete-task', CANCEL_EDIT: 'cancel-edit', SAVE_EDIT: 'save-edit',
                ADJUST_TIME: 'adjust-time'
            }
        };

        // === ICONS ===
        const Icons = {
            Clock: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>`,
            Plus: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"/><path d="M12 5v14"/></svg>`,
            Trash2: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>`,
            Calendar: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="4" rx="2" ry="2"/><line x1="16" x2="16" y1="2" y2="6"/><line x1="8" x2="8" y1="2" y2="6"/><line x1="3" x2="21" y1="10" y2="10"/></svg>`,
            AlertCircle: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/></svg>`,
            CheckCircle: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>`,
            Coffee: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 8h1a4 4 0 1 1 0 8h-1"/><path d="M3 8h14v9a4 4 0 0 1-4 4H7a4 4 0 0 1-4-4Z"/><line x1="6" x2="6" y1="2" y2="4"/><line x1="10" x2="10" y1="2" y2="4"/><line x1="14" x2="14" y1="2" y2="4"/></svg>`,
            Save: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>`,
            Briefcase: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="20" height="14" x="2" y="7" rx="2" ry="2"/><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"/></svg>`,
            BrainCircuit: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5a3 3 0 1 0-5.993.142"/><path d="M12 5a3 3 0 1 1 5.993.142"/><path d="M15 13a3 3 0 1 0-5.993.142"/><path d="M15 13a3 3 0 1 1 5.993.142"/><path d="M9 13a3 3 0 1 1 5.993.142"/><path d="M9 13a3 3 0 1 0-5.993.142"/><path d="M6 8.5A2.5 2.5 0 0 1 3.5 6v0A2.5 2.5 0 0 1 6 3.5V0"/><path d="M18 8.5A2.5 2.5 0 0 0 20.5 6v0A2.5 2.5 0 0 0 18 3.5V0"/><path d="M9 22a2.5 2.5 0 0 0 2.5-2.5v-1A2.5 2.5 0 0 0 9 16h0a2.5 2.5 0 0 0-2.5 2.5v1A2.5 2.5 0 0 0 9 22Z"/><path d="M15 22a2.5 2.5 0 0 1-2.5-2.5v-1A2.5 2.5 0 0 1 15 16h0a2.5 2.5 0 0 1 2.5 2.5v1A2.5 2.5 0 0 1 15 22Z"/><path d="M12 13a2.5 2.5 0 0 0 2.5-2.5v-1A2.5 2.5 0 0 0 12 7h0a2.5 2.5 0 0 0-2.5 2.5v1A2.5 2.5 0 0 0 12 13Z"/><path d="M12 5.5V7"/><path d="M15 13v-1.5"/><path d="M9 13v-1.5"/><path d="M18 8.5v1"/><path d="M6 8.5v1"/></svg>`,
            Printer: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 6 2 18 2 18 9"/><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/><rect width="12" height="8" x="6" y="14"/></svg>`,
            X: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" x2="6" y1="6" y2="18"/><line x1="6" x2="18" y1="6" y2="18"/></svg>`,
            Zap: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>`,
            Edit: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>`,
            TrendingUp: `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="22 7 13.5 15.5 8.5 10.5 2 17"/><polyline points="16 7 22 7 22 13"/></svg>`,
        };

        const getIcon = (name, size = 16) => {
            const svg = Icons[name] || '';
            return svg.replace('width="24"', `width="${size}"`).replace('height="24"', `height="${size}"`);
        }

        // === NOTIFICATION SYSTEM ===
        class NotificationSystem {
            static show(message, type = 'info') {
                const container = document.getElementById('notification-container');
                if (!container) return;
                const typeClasses = { success: "bg-gray-800 border-green-500 text-green-300", error: "bg-gray-800 border-red-500 text-red-300", warning: "bg-gray-800 border-yellow-500 text-yellow-300", info: "bg-gray-800 border-blue-500 text-blue-300" };
                const iconSVG = type === 'success' ? getIcon('CheckCircle', 20) : getIcon('AlertCircle', 20);
                const notificationId = `notif-${Date.now()}`;

                const notificationDiv = document.createElement('div');
                notificationDiv.id = notificationId;
                notificationDiv.className = `fixed top-5 right-5 z-50 flex items-center gap-3 px-4 py-3 rounded-lg shadow-lg animate-fade-in-down border ${typeClasses[type]}`;

                const iconSpan = document.createElement('span');
                iconSpan.innerHTML = iconSVG;

                const messageSpan = document.createElement('span');
                messageSpan.textContent = message;

                const closeButton = document.createElement('button');
                closeButton.className = "ml-4 p-1 rounded-full hover:bg-white/10";
                closeButton.innerHTML = getIcon('X', 16);
                closeButton.onclick = () => notificationDiv.remove();

                notificationDiv.appendChild(iconSpan);
                notificationDiv.appendChild(messageSpan);
                notificationDiv.appendChild(closeButton);

                // Clear previous notifications and append new one
                container.innerHTML = '';
                container.appendChild(notificationDiv);

                setTimeout(() => {
                    const el = document.getElementById(notificationId);
                    if (el) el.remove();
                }, Constants.NOTIFICATION_TIMEOUT_MS);
            }
        }

        // === TIME UTILITIES ===
        class TimeUtils {
            static minutesToTime(totalMinutes) {
                if (isNaN(totalMinutes) || totalMinutes < 0) return 'Invalid Time';
                const hours24 = Math.floor(totalMinutes / Constants.TIME.MINUTES_IN_HOUR);
                const minutes = Math.floor(totalMinutes % Constants.TIME.MINUTES_IN_HOUR); // Use floor for precision
                const period = hours24 >= Constants.TIME.HOURS_AM_PM ? 'PM' : 'AM';
                let displayHours = hours24 % Constants.TIME.HOURS_AM_PM;
                if (displayHours === 0) displayHours = Constants.TIME.HOURS_AM_PM;
                return `${displayHours}:${minutes.toString().padStart(2, '0')} ${period}`;
            }
            static timeStringToMinutes(time24h) {
                if (!time24h || !SecurityUtils.validateTimeString(time24h)) return 0;
                const [hours, minutes] = time24h.split(':').map(Number);
                return hours * Constants.TIME.MINUTES_IN_HOUR + minutes;
            }
            static minutesTo24hTime(totalMinutes) {
                if (isNaN(totalMinutes) || totalMinutes < 0) return '00:00';
                const hours24 = Math.floor(totalMinutes / Constants.TIME.MINUTES_IN_HOUR) % Constants.TIME.HOURS_IN_DAY;
                const minutes = Math.floor(totalMinutes % Constants.TIME.MINUTES_IN_HOUR); // Use floor for precision
                return `${String(hours24).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
            }
        }

        // === CONFLICT DETECTION LOGIC ===
        class ConflictDetector {
            static checkForConflicts(newItem, state, excludeId = null) {
                const { appointments, settings } = state;
                const { breaks, otherTasks, transitionTime } = settings;

                const newStartMins = TimeUtils.timeStringToMinutes(newItem.start);
                // An appointment has a `duration`, breaks/tasks have an `end` time.
                const isNewItemAppointment = newItem.hasOwnProperty('duration');
                const newEndMins = isNewItemAppointment
                    ? newStartMins + newItem.duration + transitionTime
                    : TimeUtils.timeStringToMinutes(newItem.end);

                const allItems = [
                    ...appointments.map(a => ({ ...a, itemType: 'appointment', label: a.name })),
                    ...breaks.map(b => ({ ...b, itemType: 'break' })),
                    ...otherTasks.map(t => ({ ...t, itemType: 'task' }))
                ];

                for (const item of allItems) {
                    if (excludeId && item.id === excludeId) continue;

                    // If the new item is an appointment, we only check against non-appointments.
                    if (isNewItemAppointment && item.itemType === 'appointment') {
                        continue; // Allow appointments to overlap with each other.
                    }

                    const itemStartMins = TimeUtils.timeStringToMinutes(item.start);
                    const itemEndMins = item.duration
                        ? itemStartMins + item.duration + (item.itemType === 'appointment' ? transitionTime : 0)
                        : TimeUtils.timeStringToMinutes(item.end);

                    if (newStartMins < itemEndMins && itemStartMins < newEndMins) {
                        return { hasConflict: true, conflictItem: item };
                    }
                }
                return { hasConflict: false };
            }
        }

        // === STATE MANAGEMENT ===
        class StateManager {
            constructor() {
                this.state = this.createInitialState();
                this.listeners = [];
            }
            createInitialState() {
                return {
                    settings: Constants.DEFAULT_SETTINGS,
                    appointments: [],
                    patientQueue: [],
                    schedule: null,
                    modals: { clearDay: false, editAppointment: false, editingAppointment: null },
                    dragState: { draggedItemId: null, itemType: null, initialY: 0, initialStartMins: 0, initialDuration: 0 },
                    ui: {
                        patientCounter: 1,
                        isWorkdayPanelOpen: true,
                        isTasksPanelOpen: false
                    },
                    manualCalculator: {
                        productivity: null,
                        clockOut: null,
                        txTime: null,
                        productivityInput: null,
                        clockOutInput: '',
                        lunchOut: '',
                        lunchIn: ''
                    }
                };
            }
            subscribe(listener) {
                this.listeners.push(listener);
                return () => { this.listeners = this.listeners.filter(l => l !== listener); };
            }
            setState(updates, notify = true) {
                this.state = { ...this.state, ...updates };
                if(notify) this.notifyListeners();
            }
            updateSettings(path, value) {
                const newSettings = { ...this.state.settings };
                newSettings[path] = value;
                this.setState({ settings: newSettings });
            }
            updateListItem(listName, itemId, field, value) {
                const list = this.state.settings[listName];
                const updatedList = list.map(item => String(item.id) === String(itemId) ? { ...item, [field]: value } : item);
                this.updateSettings(listName, updatedList);
            }
            notifyListeners() {
                this.listeners.forEach(listener => {
                    try { listener(this.state); }
                    catch (error) { ErrorHandler.logError(error, 'StateListener'); }
                });
            }
        }

        // === DATA PERSISTENCE ===
        class StorageManager {
            static KEYS = { SETTINGS: 'therapySchedulerSettings', APPOINTMENTS: 'therapySchedulerAppointments', QUEUE: 'therapySchedulerQueue' };
            static saveAll(state) {
                return ErrorHandler.handleStorageError(() => {
                    localStorage.setItem(this.KEYS.SETTINGS, JSON.stringify(state.settings));
                    localStorage.setItem(this.KEYS.APPOINTMENTS, JSON.stringify(state.appointments));
                    localStorage.setItem(this.KEYS.QUEUE, JSON.stringify(state.patientQueue));
                    return true;
                }, false);
            }
            static loadAll(initialState) {
                return ErrorHandler.handleStorageError(() => {
                    const settings = localStorage.getItem(this.KEYS.SETTINGS);
                    const appointments = localStorage.getItem(this.KEYS.APPOINTMENTS);
                    const patientQueue = localStorage.getItem(this.KEYS.QUEUE);
                    return {
                        settings: settings ? JSON.parse(settings) : initialState.settings,
                        appointments: appointments ? JSON.parse(appointments) : [],
                        patientQueue: patientQueue ? JSON.parse(patientQueue) : []
                    };
                }, { settings: initialState.settings, appointments: [], patientQueue: [] });
            }
        }

        // === BUSINESS LOGIC / CALCULATIONS ===
        class ScheduleCalculator {
            static calculateAppointmentLayout(items) {
                const appointments = items.filter(item => item.type === 'appointment');
                const otherItems = items.filter(item => item.type !== 'appointment');
                if (appointments.length === 0) return items;

                appointments.forEach(a => a.layout = { conflicts: [], lane: undefined, totalLanes: 1 });

                for (let i = 0; i < appointments.length; i++) {
                    for (let j = i + 1; j < appointments.length; j++) {
                        const appt1 = appointments[i];
                        const appt2 = appointments[j];
                        if (appt1.startMins < appt2.endMins && appt2.startMins < appt1.endMins) {
                            appt1.layout.conflicts.push(appt2);
                            appt2.layout.conflicts.push(appt1);
                        }
                    }
                }

                for (const appt of appointments) {
                    const occupiedLanes = appt.layout.conflicts.map(c => c.layout.lane).filter(l => l !== undefined);
                    let currentLane = 0;
                    while (occupiedLanes.includes(currentLane)) { currentLane++; }
                    appt.layout.lane = currentLane;
                }

                for (const appt of appointments) {
                    let maxLaneInGroup = appt.layout.lane;
                    for(const conflict of appt.layout.conflicts) {
                        if (conflict.layout.lane > maxLaneInGroup) maxLaneInGroup = conflict.layout.lane;
                    }
                    appt.layout.totalLanes = maxLaneInGroup + 1;
                }

                appointments.forEach(a => delete a.layout.conflicts);
                return [...appointments, ...otherItems].sort((a, b) => a.startMins - b.startMins);
            }

            static calculateScheduleMetrics(state) {
                try {
                    const allScheduledItems = [
                        ...state.settings.breaks.map(b => ({ ...b, type: 'break', startMins: TimeUtils.timeStringToMinutes(b.start), endMins: TimeUtils.timeStringToMinutes(b.end) })),
                        ...state.settings.otherTasks.map(t => ({ ...t, type: t.type, startMins: TimeUtils.timeStringToMinutes(t.start), endMins: TimeUtils.timeStringToMinutes(t.end) })),
                        ...state.appointments.map(a => ({ ...a, type: 'appointment', startMins: TimeUtils.timeStringToMinutes(a.start), endMins: TimeUtils.timeStringToMinutes(a.start) + a.duration }))
                    ].sort((a, b) => a.startMins - b.startMins);

                    const dayStartMins = TimeUtils.timeStringToMinutes(state.settings.workDay.startTime);
                    let lastEnd = dayStartMins + state.settings.setupTime;
                    allScheduledItems.forEach(item => {
                        const effectiveEndMins = item.type === 'appointment' ? item.endMins + state.settings.transitionTime : item.endMins;
                        lastEnd = Math.max(lastEnd, effectiveEndMins);
                    });

                    const gaps = this.calculateGaps(allScheduledItems, dayStartMins, state.settings);

                    const totalBillableTime = state.appointments.reduce((sum, apt) => sum + apt.duration, 0) +
                                        state.settings.otherTasks
                                            .filter(t => t.type === 'billable')
                                            .reduce((sum, t) => sum + (TimeUtils.timeStringToMinutes(t.end) - TimeUtils.timeStringToMinutes(t.start)), 0);

                    return {
                        timelineItems: [...allScheduledItems, ...gaps.map(g => ({...g, startMins: g.start, endMins: g.end }))].sort((a,b) => a.startMins - b.startMins),
                        lastEndMins: lastEnd,
                        totalBillableTime,
                        gaps
                    };
                } catch (error) { ErrorHandler.logError(error, 'ScheduleCalculation'); return null; }
            }

            static calculateGaps(allScheduledItems, dayStartMins, settings) {
                const gaps = [];
                let lastGapCheck = dayStartMins + settings.setupTime;
                allScheduledItems.forEach(item => {
                    if (item.startMins > lastGapCheck) {
                        gaps.push({ id: `gap-${lastGapCheck}`, start: lastGapCheck, end: item.startMins, duration: item.startMins - lastGapCheck, type: 'gap' });
                    }
                    const effectiveEndMins = item.type === 'appointment' ? item.endMins + settings.transitionTime : item.endMins;
                    lastGapCheck = Math.max(lastGapCheck, effectiveEndMins);
                });
                const dayEndMins = dayStartMins + (settings.workdayDurationHours * Constants.TIME.MINUTES_IN_HOUR);
                if (dayEndMins > lastGapCheck) {
                    gaps.push({ id: `gap-end-${lastGapCheck}`, start: lastGapCheck, end: dayEndMins, duration: dayEndMins - lastGapCheck, type: 'gap' });
                }
                return gaps;
            }

            static calculateProductivityMetrics(state, allScheduledItems, lastEnd) {
                const totalTreatmentTime = state.appointments.reduce((sum, apt) => sum + apt.duration, 0);
                const billableTaskTime = state.settings.otherTasks.filter(t => t.type === 'billable').reduce((sum, t) => sum + (TimeUtils.timeStringToMinutes(t.end) - TimeUtils.timeStringToMinutes(t.start)), 0);

                const totalBillableTime = totalTreatmentTime + billableTaskTime;

                let projectedClockOutMins = 0, productivity = 0;
                const dayStartMins = TimeUtils.timeStringToMinutes(state.settings.workDay.startTime);

                if (state.settings.productivityTarget > 0 && totalBillableTime > 0) {
                    const requiredTotalWorkTime = (totalBillableTime / (state.settings.productivityTarget / 100));
                    projectedClockOutMins = dayStartMins + requiredTotalWorkTime;

                    const totalMinutesOnJob = lastEnd - dayStartMins;
                    if (totalMinutesOnJob > 0) {
                        productivity = ((totalBillableTime / totalMinutesOnJob) * 100).toFixed(1);
                    }
                }
                return {
                    totalBillableTime,
                    projectedClockOutMins,
                    productivity,
                    meetsTarget: projectedClockOutMins > 0 && lastEnd >= projectedClockOutMins
                };
            }

            static generateSuggestions(state, gaps, lastEnd, metrics) {
                const suggestions = [];
                if (metrics.projectedClockOutMins > 0) {
                    suggestions.push(`To meet your <b>${state.settings.productivityTarget}% target</b>, you can clock out around <b>${TimeUtils.minutesToTime(metrics.projectedClockOutMins)}</b>.`);

                    if (lastEnd > metrics.projectedClockOutMins) {
                        suggestions.push(`Note: Your last task ends at <b>${TimeUtils.minutesToTime(lastEnd)}</b>, but you've already met your productivity goal for the time worked.`);
                    }

                } else {
                    suggestions.push(`Add a billable session to calculate your productivity and target clock-out time.`);
                }

                if (state.patientQueue.length > 0 && gaps.length > 0) {
                    const smallestPatientDuration = Math.min(...state.patientQueue.map(p => p.duration));
                    const suitableGap = gaps.find(g => g.duration >= smallestPatientDuration + state.settings.transitionTime);
                    if (suitableGap) {
                        suggestions.push(`You have a <b>${suitableGap.duration} min gap</b> at ${TimeUtils.minutesToTime(suitableGap.start)} large enough for a queued session.`);
                    }
                }

                if (lastEnd > Constants.LATE_WORK_THRESHOLD_HOUR * Constants.TIME.MINUTES_IN_HOUR) {
                    suggestions.push(`<b>Warning:</b> Your current schedule ends at <b>${TimeUtils.minutesToTime(lastEnd)}</b>.`);
                }
                return suggestions;
            }
        }

        // === APPLICATION CONTROLLER ===
        class TherapySchedulerApp {
            constructor() {
                this.stateManager = new StateManager();
                this.renderer = new AppRenderer();
                this.eventHandler = new EventHandler(this.stateManager, this);
                this.stateManager.subscribe(() => this.renderer.update(this.stateManager.state));
                this.init();
            }
            init() {
                try {
                    this.renderer.initialRender();
                    const loadedData = StorageManager.loadAll(this.stateManager.state);
                    const allPatients = [...(loadedData.appointments || []), ...(loadedData.patientQueue || [])];
                    const maxId = allPatients.reduce((max, patient) => {
                        const num = parseInt(patient.name?.replace('P', ''), 10);
                        return isNaN(num) ? max : Math.max(max, num);
                    }, 0);

                    this.updateStateAndSchedule({ ...loadedData, ui: { ...this.stateManager.state.ui, patientCounter: maxId + 1 } });
                } catch (error) { ErrorHandler.logError(error, 'AppInit'); }
            }

            updateStateAndSchedule(updates) {
                this.stateManager.setState(updates, false); // Update state without notifying yet
                const nextState = this.stateManager.state;
                const schedule = ScheduleCalculator.calculateScheduleMetrics(nextState);

                const { productivityCalculator } = nextState;
                let newProdCalc = { ...productivityCalculator };
                // Only auto-update the calculator's end time if it hasn't been manually set from the default
                if (schedule && schedule.projectedClockOutMins > 0 && productivityCalculator.endTime === Constants.DEFAULT_END_TIME) {
                    newProdCalc.endTime = TimeUtils.minutesTo24hTime(schedule.projectedClockOutMins);
                }

                this.stateManager.setState({ schedule, productivityCalculator: newProdCalc }, true); // Now update schedule and notify
            }
            
            saveAll() {
                if (StorageManager.saveAll(this.stateManager.state)) {
                    NotificationSystem.show('Settings and schedule saved!', 'success');
                }
            }
        }

        // === UI EVENT HANDLING (REVISED) ===
        class EventHandler {
            constructor(stateManager, app) {
                this.stateManager = stateManager;
                this.app = app;
                this.root = document.getElementById('app-root');
                this.setupDelegatedEvents();
            }
            
            setupDelegatedEvents() {
                this.root.addEventListener('click', this.handleClick.bind(this));
                this.root.addEventListener('input', this.handleInput.bind(this));
                this.root.addEventListener('keydown', this.handleKeydown.bind(this));
                this.root.addEventListener('dragstart', this.handleDragStart.bind(this));
                this.root.addEventListener('dragend', () => this.stateManager.setState({ dragState: { draggedItemId: null } }, false));
                this.root.addEventListener('dragover', (e) => { if (e.target.closest('.timeline-gap, #timeline-droppable')) e.preventDefault(); });
                this.root.addEventListener('drop', this.handleDrop.bind(this));
                this.root.addEventListener('blur', this.handleBlur.bind(this), true);
                this.root.addEventListener('toggle', this.handleToggle.bind(this), true);
            }

            handleToggle(e) {
                if (e.target.tagName === 'DETAILS') {
                    const panelId = e.target.id;
                    const { ui } = this.stateManager.state;
                    let updates = {};
                    if (panelId === 'details-workday') {
                        updates = { ui: { ...ui, isWorkdayPanelOpen: e.target.open }};
                    } else if (panelId === 'details-tasks') {
                        updates = { ui: { ...ui, isTasksPanelOpen: e.target.open }};
                    }
                    this.stateManager.setState(updates, false); // Don't trigger a full re-render
                }
            }
            
            handleClick(e) {
                const btn = e.target.closest('button');
                if (!btn) return;

                const { modals } = this.stateManager.state;
                const action = btn.dataset.action;
                const id = btn.dataset.id;

                switch(action) {
                    case "get-productivity": this.getProductivity(); break;
                    case "get-clock-out": this.getClockOut(); break;
                    case Constants.ACTIONS.SAVE: this.app.saveAll(); break;
                    case Constants.ACTIONS.PRINT: window.print(); break;
                    case Constants.ACTIONS.CLEAR_DAY: this.stateManager.setState({ modals: { ...modals, clearDay: true }}); break;
                    case Constants.ACTIONS.CONFIRM_CLEAR: this.clearDay(); break;
                    case Constants.ACTIONS.CANCEL_CLEAR: this.stateManager.setState({ modals: { ...modals, clearDay: false }}); break;
                    case Constants.ACTIONS.ADD_PATIENT: this.addPatient(); break;
                    case Constants.ACTIONS.ADD_PATIENT_PRESET: this.addPatientToQueue(parseInt(btn.dataset.duration)); break;
                    case Constants.ACTIONS.REMOVE_PATIENT: this.removePatientFromQueue(btn.closest('[data-patient-id]').dataset.patientId); break;
                    case Constants.ACTIONS.AUTO_SCHEDULE: this.autoSchedule(); break;
                    case Constants.ACTIONS.EDIT_APPOINTMENT: this.openEditModal(btn.closest('[data-id]').dataset.id); break;
                    case Constants.ACTIONS.TOGGLE_COMPLETE: this.toggleAppointmentComplete(btn.closest('[data-id]').dataset.id); break;
                    case Constants.ACTIONS.DELETE_APPOINTMENT: this.removeAppointment(btn.closest('[data-id]').dataset.id); break;
                    case Constants.ACTIONS.CANCEL_EDIT: this.stateManager.setState({ modals: { ...modals, editAppointment: false, editingAppointment: null }}); break;
                    case Constants.ACTIONS.SAVE_EDIT: this.saveAppointmentChanges(); break;
                    case Constants.ACTIONS.ADD_BREAK: {
                        const scheduleForBreak = this.stateManager.state.schedule;
                        const lastEndMinsForBreak = scheduleForBreak ? scheduleForBreak.lastEndMins : TimeUtils.timeStringToMinutes('12:00');
                        const newStartForBreak = TimeUtils.minutesTo24hTime(lastEndMinsForBreak);
                        const newEndForBreak = TimeUtils.minutesTo24hTime(lastEndMinsForBreak + 30);
                        this.addListItem('breaks', { start: newStartForBreak, end: newEndForBreak, label: 'New Break' });
                        break;
                    }
                    case Constants.ACTIONS.ADD_TASK: {
                        const scheduleForTask = this.stateManager.state.schedule;
                        const lastEndMinsForTask = scheduleForTask ? scheduleForTask.lastEndMins : TimeUtils.timeStringToMinutes('15:00');
                        const newStartForTask = TimeUtils.minutesTo24hTime(lastEndMinsForTask);
                        const newEndForTask = TimeUtils.minutesTo24hTime(lastEndMinsForTask + 30);
                        this.addListItem('otherTasks', { start: newStartForTask, end: newEndForTask, label: 'New Task', type: 'non-billable' });
                        break;
                    }
                    case Constants.ACTIONS.DELETE_BREAK: this.removeListItem('breaks', id); break;
                    case Constants.ACTIONS.DELETE_TASK: this.removeListItem('otherTasks', id); break;
                    case Constants.ACTIONS.ADJUST_TIME:
                        const { amount } = btn.dataset;
                        const timeContainer = btn.closest('.flex.items-center.gap-2').querySelector('.custom-time-input');
                        this.adjustTime(timeContainer, parseInt(amount));
                        break;
                }

                if (btn.classList.contains('am-pm-btn')) {
                    const timeContainer = btn.closest('.custom-time-input');
                    this.updateTimeFromUI(timeContainer);
                }
            }

            getProductivity() {
                const { manualCalculator, settings, schedule } = this.stateManager.state;
                const txTime = manualCalculator.txTime || schedule.totalBillableTime;
                const clockIn = settings.workDay.startTime;
                const lunchOut = manualCalculator.lunchOut;
                const lunchIn = manualCalculator.lunchIn;
                const clockOut = manualCalculator.clockOutInput;

                if (!clockOut) {
                    NotificationSystem.show("Please enter a Clock Out time to calculate productivity.", "warning");
                    return;
                }

                let clockInMinutes = TimeUtils.timeStringToMinutes(clockIn);
                let clockOutMinutes = TimeUtils.timeStringToMinutes(clockOut);
                let lunchOutMinutes = TimeUtils.timeStringToMinutes(lunchOut);
                let lunchInMinutes = TimeUtils.timeStringToMinutes(lunchIn);

                if (clockOutMinutes < clockInMinutes) clockOutMinutes += 24 * 60;
                if (lunchOutMinutes < clockInMinutes && lunchOut) lunchOutMinutes += 24 * 60;
                if (lunchInMinutes < lunchOutMinutes && lunchIn) lunchInMinutes += 24 * 60;

                const dayLength = clockOutMinutes - clockInMinutes;
                const lunchBreak = (lunchInMinutes > lunchOutMinutes) ? (lunchInMinutes - lunchOutMinutes) : 0;
                const workTime = dayLength - lunchBreak;

                let productivity = "0.0 %";
                if (workTime > 0) {
                    const calculatedProductivity = (txTime * 100) / workTime;
                    productivity = calculatedProductivity.toFixed(1) + " %";
                }

                this.stateManager.setState({
                    manualCalculator: {
                        ...this.stateManager.state.manualCalculator,
                        productivity: productivity
                    }
                });
            }

            getClockOut() {
                const { manualCalculator, settings, schedule } = this.stateManager.state;
                const txTime = manualCalculator.txTime || schedule.totalBillableTime;
                const clockIn = settings.workDay.startTime;
                const lunchOut = manualCalculator.lunchOut;
                const lunchIn = manualCalculator.lunchIn;
                const productivityInput = manualCalculator.productivityInput || settings.productivityTarget;

                if (productivityInput <= 0) {
                    NotificationSystem.show("Please enter a valid Target Productivity.", "warning");
                    return;
                }

                let clockInMinutes = TimeUtils.timeStringToMinutes(clockIn);
                let lunchOutMinutes = TimeUtils.timeStringToMinutes(lunchOut);
                let lunchInMinutes = TimeUtils.timeStringToMinutes(lunchIn);

                if (lunchOutMinutes < clockInMinutes && lunchOut) lunchOutMinutes += 24 * 60;
                if (lunchInMinutes < lunchOutMinutes && lunchIn) lunchInMinutes += 24 * 60;

                const lunchBreak = (lunchInMinutes > lunchOutMinutes) ? (lunchInMinutes - lunchOutMinutes) : 0;
                const requiredWorkMinutes = (txTime * 100) / productivityInput;
                const clockOutMinutes = clockInMinutes + requiredWorkMinutes + lunchBreak;

                this.stateManager.setState({
                    manualCalculator: {
                        ...this.stateManager.state.manualCalculator,
                        clockOut: TimeUtils.minutesToTime(clockOutMinutes)
                    }
                });
            }

            handleCalculatorInputChange(target) {
                const { dataset, value, type } = target;
                const field = dataset.calculatorField;
                const val = type === 'number' ? (parseFloat(value) || null) : value;

                const { manualCalculator } = this.stateManager.state;
                const newCalculatorState = { ...manualCalculator, [field]: val };
                this.stateManager.setState({ manualCalculator: newCalculatorState });
            }

            handleInput(e) {
                const { value, dataset, id } = e.target;
                 if (id === 'edit-duration-input') {
                    this._handleModalInputChange({ duration: value });
                } else if (dataset.field) {
                    this.handleSettingChange(e.target);
                } else if (dataset.calculatorField) {
                    this.handleCalculatorInputChange(e.target);
                }
            }

            handleBlur(e) {
                const { target } = e;
                if (target.classList.contains('time-input-hour') || target.classList.contains('time-input-minute')) {
                    const container = target.closest('.custom-time-input');
                    if (container && !container.contains(e.relatedTarget)) {
                        this.updateTimeFromUI(container);
                    }
                }
                if (e.target.dataset.field) {
                    this.handleSettingChange(e.target);
                }
            }

            handleKeydown(e) {
                if (e.key === 'Enter') {
                    if (e.target.id === 'patient-duration-input') { e.preventDefault(); this.addPatient(); }
                    else if (e.target.closest('#modal-container')) { e.preventDefault(); this.saveAppointmentChanges(); }
                }
            }

            handleDragStart(e) {
                const draggableItem = e.target.closest('[draggable="true"]');
                if (!draggableItem) return;

                const draggedId = draggableItem.dataset.id || draggableItem.dataset.patientId;
                if (draggedId) {
                    const itemType = draggableItem.classList.contains('patient-item') ? 'queue' :
                                   draggableItem.dataset.itemType;
                    this.stateManager.setState({
                        dragState: {
                            ...this.stateManager.state.dragState,
                            draggedItemId: draggedId,
                            itemType: itemType
                        }
                    }, false);
                }
            }

            handleDrop(e) {
                e.preventDefault();
                const gapEl = e.target.closest('.timeline-gap');
                const { draggedItemId, itemType } = this.stateManager.state.dragState;

                if (!gapEl || !draggedItemId) {
                    this.stateManager.setState({ dragState: { ...this.stateManager.state.dragState, draggedItemId: null, itemType: null } }, false);
                    return;
                }

                const { appointments, patientQueue, settings } = this.stateManager.state;
                let draggedItem = null;

                if (itemType === 'queue') {
                    draggedItem = patientQueue.find(p => p.id === draggedItemId);
                } else if (itemType === 'appointment') {
                    draggedItem = appointments.find(a => a.id === draggedItemId);
                } else {
                    draggedItem = settings.breaks.find(b => b.id === draggedItemId) || settings.otherTasks.find(t => t.id === draggedItemId);
                }

                if (draggedItem) {
                    const gap = { start: parseInt(gapEl.dataset.start), duration: parseInt(gapEl.dataset.duration) };
                    const itemDuration = (itemType === 'break' || itemType === 'task' || itemType === 'billable' || itemType === 'non-billable')
                        ? TimeUtils.timeStringToMinutes(draggedItem.end) - TimeUtils.timeStringToMinutes(draggedItem.start)
                        : draggedItem.duration;

                    const transition = (itemType === 'queue' || itemType === 'appointment') ? settings.transitionTime : 0;

                    if (gap.duration >= itemDuration + transition) {
                        const newStartMins = gap.start;
                        const newStart = TimeUtils.minutesTo24hTime(newStartMins);
                        const newEnd = TimeUtils.minutesTo24hTime(newStartMins + itemDuration);

                        const movedItem = { ...draggedItem, start: newStart };
                        if (itemType === 'break' || itemType === 'task' || itemType === 'billable' || itemType === 'non-billable') {
                            movedItem.end = newEnd;
                        }

                        const conflict = ConflictDetector.checkForConflicts(movedItem, this.stateManager.state, draggedItemId);
                        if (conflict.hasConflict) {
                            NotificationSystem.show(`Move conflicts with ${conflict.conflictItem.label || conflict.conflictItem.name}.`, 'error');
                        } else {
                            let newAppointments = [...appointments];
                            let newQueue = [...patientQueue];
                            let newSettings = { ...settings };

                            if (itemType === 'queue') {
                                newAppointments.push({ ...draggedItem, id: `appt-${Date.now()}`, start: newStart, completed: false });
                                newQueue = newQueue.filter(p => p.id !== draggedItemId);
                            } else if (itemType === 'appointment') {
                                newAppointments = newAppointments.map(a => a.id === draggedItemId ? { ...a, start: newStart } : a);
                            } else if (itemType === 'break' || itemType === 'billable' || itemType === 'non-billable') {
                                const listName = (itemType === 'break') ? 'breaks' : 'otherTasks';
                                const updatedList = newSettings[listName].map(item =>
                                    item.id === draggedItemId ? { ...item, start: newStart, end: newEnd } : item
                                );
                                newSettings[listName] = updatedList;
                            }

                            this.app.updateStateAndSchedule({
                                appointments: newAppointments.sort((a, b) => TimeUtils.timeStringToMinutes(a.start) - TimeUtils.timeStringToMinutes(b.start)),
                                patientQueue: newQueue,
                                settings: newSettings
                            });
                        }
                    } else {
                        NotificationSystem.show(`Item (${itemDuration}m) does not fit in gap (${gap.duration}m).`, 'error');
                    }
                }

                this.stateManager.setState({ dragState: { ...this.stateManager.state.dragState, draggedItemId: null, itemType: null } }, false);
            }
            
            autoSchedule() {
                let { patientQueue, appointments, settings } = this.stateManager.state;
                if (patientQueue.length === 0) {
                    NotificationSystem.show("Patient queue is empty.", "info");
                    return;
                }
                const sortedQueue = [...patientQueue].sort((a, b) => b.duration - a.duration);
                const newAppointments = [...appointments];
                const scheduledPatientIds = new Set();

                sortedQueue.forEach(patient => {
                    const tempState = { ...this.stateManager.state, appointments: newAppointments, patientQueue: [] };
                    const tempSchedule = ScheduleCalculator.calculateScheduleMetrics(tempState);

                    const requiredDuration = patient.duration + settings.transitionTime;
                    const suitableGap = tempSchedule.gaps.find(g => g.duration >= requiredDuration);
                    if (suitableGap) {
                        newAppointments.push({ ...patient, id: `appt-${Date.now()}-${patient.id}`, start: TimeUtils.minutesTo24hTime(suitableGap.start), completed: false });
                        scheduledPatientIds.add(patient.id);
                    }
                });

                if (scheduledPatientIds.size > 0) {
                    this.app.updateStateAndSchedule({
                        appointments: newAppointments,
                        patientQueue: patientQueue.filter(p => !scheduledPatientIds.has(p.id))
                    });
                    NotificationSystem.show(`${scheduledPatientIds.size} patient(s) auto-scheduled!`, "success");
                } else {
                    NotificationSystem.show("No suitable gaps found to schedule patients.", "warning");
                }
            }

            addPatient() {
                const input = document.getElementById('patient-duration-input');
                if (!input || !input.value) return;
                this.addPatientToQueue(parseInt(input.value));
                input.value = '';
            }
            
            addPatientToQueue(duration) {
                if (!SecurityUtils.validateDuration(duration)) {
                    NotificationSystem.show(`Duration must be between ${Constants.MINIMUM_SCHEDULABLE_DURATION} and ${Constants.MAXIMUM_SCHEDULABLE_DURATION} minutes.`, 'error');
                    return;
                }
                const { patientQueue, ui } = this.stateManager.state;
                const newPatient = { id: `p${Date.now()}`, name: `P${ui.patientCounter}`, duration };
                this.app.updateStateAndSchedule({
                    patientQueue: [...patientQueue, newPatient],
                    ui: { ...ui, patientCounter: ui.patientCounter + 1 }
                });
                NotificationSystem.show(`Patient ${newPatient.name} added to queue.`, 'success');
            }
            
            removePatientFromQueue(id) {
                const { patientQueue } = this.stateManager.state;
                this.app.updateStateAndSchedule({ patientQueue: patientQueue.filter(p => p.id !== id) });
            }

            openEditModal(id) {
                const appointment = this.stateManager.state.appointments.find(a => a.id === id);
                if (appointment) {
                    const startMins = TimeUtils.timeStringToMinutes(appointment.start);
                    const endMins = startMins + appointment.duration;
                    const editingAppointment = { ...appointment, end: TimeUtils.minutesTo24hTime(endMins) };
                    this.stateManager.setState({ modals: { ...this.stateManager.state.modals, editAppointment: true, editingAppointment }});
                }
            }

            _handleModalInputChange(updates) {
                const { modals } = this.stateManager.state;
                let newAppointmentState = { ...modals.editingAppointment, ...updates };
                const changedKey = Object.keys(updates)[0];

                let startMins = TimeUtils.timeStringToMinutes(newAppointmentState.start);
                let duration = parseInt(newAppointmentState.duration, 10);
                let endMins = TimeUtils.timeStringToMinutes(newAppointmentState.end);

                if (changedKey === 'start') {
                    endMins = startMins + duration;
                    newAppointmentState.end = TimeUtils.minutesTo24hTime(endMins);
                } else if (changedKey === 'duration') {
                    duration = isNaN(duration) ? 0 : duration;
                    endMins = startMins + duration;
                    newAppointmentState.end = TimeUtils.minutesTo24hTime(endMins);
                } else if (changedKey === 'end') {
                    duration = endMins - startMins;
                    if (duration < 0) duration = 0;
                    newAppointmentState.duration = duration;
                }
                this.stateManager.setState({ modals: { ...modals, editingAppointment: newAppointmentState }});
            }

            saveAppointmentChanges() {
                const { editingAppointment } = this.stateManager.state.modals;

                if (!SecurityUtils.validateDuration(editingAppointment.duration)) {
                    NotificationSystem.show('Invalid duration. Must be at least 5 minutes.', 'error'); return;
                }

                const updatedAppointment = { ...editingAppointment };
                delete updatedAppointment.end; // Remove temporary 'end' property

                const conflict = ConflictDetector.checkForConflicts(updatedAppointment, this.stateManager.state, editingAppointment.id);

                if (conflict.hasConflict) {
                    NotificationSystem.show(`Change conflicts with ${conflict.conflictItem.label || conflict.conflictItem.name}.`, 'error');
                    return;
                }

                const updatedAppointments = this.stateManager.state.appointments.map(apt =>
                    apt.id === editingAppointment.id ? updatedAppointment : apt
                );

                this.app.updateStateAndSchedule({
                    appointments: updatedAppointments,
                    modals: { ...this.stateManager.state.modals, editAppointment: false, editingAppointment: null }
                });
                NotificationSystem.show('Session updated!', 'success');
            }

            toggleAppointmentComplete(id) {
                const updatedAppointments = this.stateManager.state.appointments.map(apt =>
                    apt.id === id ? { ...apt, completed: !apt.completed } : apt
                );
                this.app.updateStateAndSchedule({ appointments: updatedAppointments });
            }

            removeAppointment(id) {
                const appointmentToRemove = this.stateManager.state.appointments.find(a => a.id === id);
                if (!appointmentToRemove) return;

                const newAppointments = this.stateManager.state.appointments.filter(a => a.id !== id);
                const newPatientQueue = [...this.stateManager.state.patientQueue];
                const patientInQueue = newPatientQueue.find(p => p.name === appointmentToRemove.name);

                if (!patientInQueue) {
                     newPatientQueue.unshift({ id: `p${Date.now()}`, name: appointmentToRemove.name, duration: appointmentToRemove.duration });
                }

                this.app.updateStateAndSchedule({ appointments: newAppointments, patientQueue: newPatientQueue });
            }

            addListItem(listName, itemData) {
                const newItem = { ...itemData, id: `${listName.slice(0, -1)}-${Date.now()}` };

                const conflict = ConflictDetector.checkForConflicts(newItem, this.stateManager.state);
                if (conflict.hasConflict) {
                    NotificationSystem.show(`New item conflicts with ${conflict.conflictItem.label || conflict.conflictItem.name}.`, 'error');
                    return;
                }

                const list = this.stateManager.state.settings[listName] || [];
                const updates = { settings: { ...this.stateManager.state.settings, [listName]: [...list, newItem] } };
                this.app.updateStateAndSchedule(updates);
            }

            removeListItem(listName, id) {
                const list = this.stateManager.state.settings[listName] || [];
                const updates = { settings: { ...this.stateManager.state.settings, [listName]: list.filter(item => String(item.id) !== id) } };
                this.app.updateStateAndSchedule(updates);
            }

            handleSettingChange(target) {
                const { dataset, value, type } = target;
                const val = type === 'number' ? parseInt(value) || 0 : value;
                let updates;

                if (dataset.list && dataset.id && dataset.field) {
                    const list = this.stateManager.state.settings[dataset.list];
                    const updatedList = list.map(item => String(item.id) === dataset.id ? { ...item, [dataset.field]: val } : item);
                    updates = { settings: { ...this.stateManager.state.settings, [dataset.list]: updatedList }};
                } else if (dataset.field) {
                    updates = { settings: { ...this.stateManager.state.settings, [dataset.field]: val }};
                }
                if(updates) this.app.updateStateAndSchedule(updates);
            }

            get24hTimeFromUI(container) {
                if (!container) return null;
                const hourInput = container.querySelector('.time-input-hour');
                const minuteInput = container.querySelector('.time-input-minute');
                const amButton = container.querySelector('.am-pm-btn[data-period="AM"]');
                let hour12 = parseInt(hourInput.value) || 12;
                const minute = parseInt(minuteInput.value) || 0;
                const period = amButton.classList.contains('bg-yellow-500') ? 'AM' : 'PM';
                let hour24 = hour12;
                if (period === 'PM' && hour12 < 12) hour24 += 12;
                if (period === 'AM' && hour12 === 12) hour24 = 0;
                return TimeUtils.minutesTo24hTime(hour24 * 60 + minute);
            }

            _updateTimeValue(id, newTime) {
                const parts = id.split('.');

                if (parts[0] === 'edit') {
                    this._handleModalInputChange({ [parts[1]]: newTime });
                    return;
                }

                let updates = {};

                if (parts[0] === 'productivity') {
                    updates = { productivityCalculator: { ...this.stateManager.state.productivityCalculator, endTime: newTime }};
                } else {
                    const oldSettings = this.stateManager.state.settings;
                    const listName = parts[0];
                    const field = parts[parts.length - 1];

                    if (parts.length === 2 && listName === 'workDay') {
                        updates = { settings: { ...oldSettings, workDay: { ...oldSettings.workDay, [field]: newTime } } };
                    } else if (parts.length === 3) {
                        const itemId = parts[1];
                        const tempList = [...oldSettings[listName]];
                        const itemIndex = tempList.findIndex(i => String(i.id) === itemId);

                        if (itemIndex > -1) {
                            const tempItem = {...tempList[itemIndex], [field]: newTime};

                            const startMins = TimeUtils.timeStringToMinutes(field === 'start' ? newTime : tempItem.start);
                            const endMins = TimeUtils.timeStringToMinutes(field === 'end' ? newTime : tempItem.end);

                            if (endMins < startMins) {
                                NotificationSystem.show('End time cannot be before start time.', 'error');
                                this.app.updateStateAndSchedule({});
                                return;
                            }

                            const conflict = ConflictDetector.checkForConflicts(tempItem, this.stateManager.state, itemId);
                            if(conflict.hasConflict) {
                                NotificationSystem.show(`Change conflicts with ${conflict.conflictItem.label || conflict.conflictItem.name}.`, 'error');
                                this.app.updateStateAndSchedule({});
                                return;
                            }

                            tempList[itemIndex] = tempItem;
                            updates = { settings: { ...oldSettings, [listName]: tempList }};
                        }
                    }
                }

                if (Object.keys(updates).length > 0) {
                    this.app.updateStateAndSchedule(updates);
                }
            }

            updateTimeFromUI(container) {
                const id = container.dataset.id;
                const newTime = this.get24hTimeFromUI(container);
                this._updateTimeValue(id, newTime);
            }

            adjustTime(container, amount) {
                if (!container) return;
                const timeInMinutes = TimeUtils.timeStringToMinutes(this.get24hTimeFromUI(container));
                const adjustedTime = TimeUtils.minutesTo24hTime(timeInMinutes + amount);
                const id = container.dataset.id;
                this._updateTimeValue(id, adjustedTime);
            }

            clearDay() {
                this.app.updateStateAndSchedule({
                    appointments: [],
                    patientQueue: [],
                    ui: { ...this.stateManager.state.ui, patientCounter: 1 },
                    modals: { ...this.stateManager.state.modals, clearDay: false }
                });
                NotificationSystem.show('Your schedule has been cleared.', 'success');
            }
        }


        // === UI RENDERER ===
        class AppRenderer {
            constructor() {
                this.root = document.getElementById('app-root');
                this.initialScrollDone = false;
            }
            initialRender() {
                this.root.innerHTML = `
                    <div class="max-w-full mx-auto px-4 sm:px-6 lg:px-8 py-4 sm:py-6 min-h-screen printable-area">
                        <div id="notification-container"></div>
                        <div id="modal-container"></div>
                        <div id="header-container" class="no-print"></div>
                        <div class="grid grid-cols-1 lg:grid-cols-5 gap-6">
                            <div class="lg:col-span-1 space-y-6 no-print">
                                <div id="patient-queue-container"></div>
                                <div id="settings-panel-container"></div>
                            </div>
                            <div class="lg:col-span-4 space-y-6">
                                <div id="day-summary-container"></div>
                                <div id="schedule-timeline-container"></div>
                            </div>
                        </div>
                    </div>
                `;
            }
            update(state) {
                this._renderHeader();
                this._renderModals(state.modals);
                this._renderPatientQueue(state.patientQueue);
                this._renderSettingsPanel(state.settings, state.ui);
                this._renderDaySummary(state.schedule, state.appointments, state.patientQueue, state.settings, state.manualCalculator);
                this._renderScheduleTimeline(state.schedule, state.settings);
            }

            _renderHeader() {
                document.getElementById('header-container').innerHTML = `
                    <div class="bg-gray-800 rounded-lg shadow-lg p-4 sm:p-6 mb-6 border border-gray-700">
                        <div class="flex flex-col sm:flex-row sm:justify-between sm:items-start gap-4">
                            <div>
                                <h1 class="text-3xl sm:text-4xl font-bold text-gray-100 mb-2 flex items-center gap-2">
                                    <span class="text-yellow-400">${getIcon('Calendar', 28)}</span>
                                    Interactive Therapy Scheduler
                                </h1>
                                <p class="text-base text-gray-400">Add patients, then drag them to the timeline or use the optimizer.</p>
                            </div>
                            <div class="flex flex-col sm:flex-row gap-2 shrink-0 w-full sm:w-auto">
                                <button data-action="${Constants.ACTIONS.SAVE}" class="flex items-center justify-center gap-2 w-full sm:w-auto px-4 py-2 bg-yellow-500 text-gray-900 font-semibold rounded-lg hover:bg-yellow-400">${getIcon('Save')}Save</button>
                                <button data-action="${Constants.ACTIONS.PRINT}" class="flex items-center justify-center gap-2 w-full sm:w-auto px-4 py-2 bg-gray-600 text-gray-200 rounded-lg hover:bg-gray-500">${getIcon('Printer')}Print</button>
                                <button data-action="${Constants.ACTIONS.CLEAR_DAY}" class="flex items-center justify-center gap-2 w-full sm:w-auto px-4 py-2 bg-red-800/80 text-red-200 rounded-lg hover:bg-red-700/80">${getIcon('Trash2')}Clear Day</button>
                            </div>
                        </div>
                    </div>`;
            }

            _renderModals({ clearDay, editAppointment, editingAppointment }) {
                const container = document.getElementById('modal-container');
                if (!container) return;
                container.innerHTML = '';
                if (clearDay) {
                    const modalDiv = document.createElement('div');
                    modalDiv.className = "fixed inset-0 bg-black bg-opacity-70 z-50 flex justify-center items-center p-4";
                    modalDiv.innerHTML = `<div class="bg-gray-800 border border-gray-700 rounded-lg shadow-xl p-6 w-full max-w-md animate-fade-in-down"><div class="flex justify-between items-center mb-4"><h2 class="text-2xl font-bold text-yellow-400">Confirm Clear Day</h2><button data-action="${Constants.ACTIONS.CANCEL_CLEAR}" class="p-1 rounded-full text-gray-400 hover:bg-gray-700">${getIcon('X', 20)}</button></div><div class="text-base text-gray-300 mb-6">Are you sure? This action cannot be undone.</div><div class="flex justify-end gap-3"><button data-action="${Constants.ACTIONS.CANCEL_CLEAR}" class="px-4 py-2 bg-gray-600 text-gray-200 rounded-lg hover:bg-gray-500">Cancel</button><button data-action="${Constants.ACTIONS.CONFIRM_CLEAR}" class="px-4 py-2 bg-red-800/80 text-red-200 rounded-lg hover:bg-red-700/80">Confirm</button></div></div></div>`;
                    container.appendChild(modalDiv);
                }
                else if (editAppointment && editingAppointment) {
                    const modalWrapper = document.createElement('div');
                    modalWrapper.className = "fixed inset-0 bg-black bg-opacity-70 z-50 flex justify-center items-center p-4";

                    const modalContent = document.createElement('div');
                    modalContent.className = "bg-gray-800 border border-gray-700 rounded-lg shadow-xl p-6 w-full max-w-md animate-fade-in-down";

                    const header = document.createElement('div');
                    header.className = "flex justify-between items-center mb-4";
                    const title = document.createElement('h2');
                    title.className = "text-2xl font-bold text-yellow-400";
                    title.textContent = `Edit Session: ${editingAppointment.name}`;
                    const closeButton = document.createElement('button');
                    closeButton.dataset.action = Constants.ACTIONS.CANCEL_EDIT;
                    closeButton.className = "p-1 rounded-full text-gray-400 hover:bg-gray-700";
                    closeButton.innerHTML = getIcon('X', 20);
                    header.appendChild(title);
                    header.appendChild(closeButton);

                    const body = document.createElement('div');
                    body.className = "mb-6 space-y-4";
                    body.innerHTML = `
                        <div><label class="block text-base font-medium text-gray-300 mb-1">Start Time</label>${this._renderCustomTimeInput(editingAppointment.start, 'edit.start')}</div>
                        <div><label class="block text-base font-medium text-gray-300 mb-1">End Time</label>${this._renderCustomTimeInput(editingAppointment.end, 'edit.end')}</div>
                        <div><label for="edit-duration-input" class="block text-base font-medium text-gray-300">Duration (minutes)</label><input id="edit-duration-input" type="number" value="${editingAppointment.duration}" class="w-full mt-1 px-3 py-2 bg-gray-700 border-gray-600 text-gray-200 rounded-md focus:ring-yellow-500 focus:border-yellow-500" /></div>`;

                    const footer = document.createElement('div');
                    footer.className = "flex justify-end gap-3";
                    footer.innerHTML = `<button data-action="${Constants.ACTIONS.CANCEL_EDIT}" class="px-4 py-2 bg-gray-600 text-gray-200 rounded-lg hover:bg-gray-500">Cancel</button><button data-action="${Constants.ACTIONS.SAVE_EDIT}" class="px-4 py-2 bg-yellow-500 text-gray-900 font-semibold rounded-lg hover:bg-yellow-400">Save Changes</button>`;

                    modalContent.appendChild(header);
                    modalContent.appendChild(body);
                    modalContent.appendChild(footer);
                    modalWrapper.appendChild(modalContent);
                    container.appendChild(modalWrapper);

                    const durationInput = document.getElementById('edit-duration-input');
                    if (durationInput) durationInput.focus();
                }
            }

            _renderPatientQueue(queue) {
                 document.getElementById('patient-queue-container').innerHTML = `
                    <div class="bg-gray-800 rounded-lg shadow-lg p-4 border border-gray-700">
                        <h2 class="text-2xl font-semibold text-gray-200 mb-4 flex items-center gap-2"><span class="text-yellow-400">${getIcon('Clock', 20)}</span>Patient Queue (${queue.length})</h2>
                        <div class="flex gap-2 mb-2">
                            <input id="patient-duration-input" type="number" placeholder="Duration (min)" class="w-full px-3 py-2 bg-gray-700 border-gray-600 text-gray-200 rounded-md focus:ring-yellow-500 focus:border-yellow-500" />
                            <button data-action="${Constants.ACTIONS.ADD_PATIENT}" class="px-4 py-2 bg-yellow-500 text-gray-900 font-semibold rounded-lg hover:bg-yellow-400 shrink-0">${getIcon('Plus', 16)}</button>
                        </div>
                        <div class="grid grid-cols-4 gap-2 mb-4">
                            ${Constants.PATIENT_PRESET_DURATIONS.map(d => `<button data-action="${Constants.ACTIONS.ADD_PATIENT_PRESET}" data-duration="${d}" class="w-full py-1 text-base bg-gray-700 text-gray-300 rounded hover:bg-gray-600">+${d}</button>`).join('')}
                        </div>
                        <div id="patient-list" class="space-y-2 max-h-48 overflow-y-auto p-1 bg-gray-900/50 rounded min-h-[4rem]">
                            ${queue.map(p => `<div draggable="true" class="patient-item flex justify-between items-center p-2 rounded-md shadow-sm cursor-grab active:cursor-grabbing border ${this._getAppointmentColor(p.duration)}" data-patient-id="${p.id}"><span class="font-semibold text-base">${p.name} (${p.duration} min)</span><button data-action="${Constants.ACTIONS.REMOVE_PATIENT}" class="p-1 hover:bg-white/10 rounded-full">${getIcon('Trash2', 14)}</button></div>`).join('')}
                        </div>
                        <button data-action="${Constants.ACTIONS.AUTO_SCHEDULE}" class="w-full mt-4 py-2 px-4 bg-gray-700 text-yellow-300 font-semibold rounded-lg hover:bg-gray-600 flex items-center justify-center gap-2">${getIcon('Zap')} Optimize Schedule</button>
                    </div>`;
            }

            _renderSettingsPanel(settings, ui) {
                const container = document.getElementById('settings-panel-container');
                if (!container) return;
                container.innerHTML = '';

                const createDetailsSection = (id, title, isOpen) => {
                    const details = document.createElement('details');
                    details.id = id;
                    details.className = "bg-gray-800 rounded-lg shadow-lg p-4 border border-gray-700";
                    details.open = isOpen;

                    const summary = document.createElement('summary');
                    summary.className = "font-semibold text-xl text-gray-200 cursor-pointer";
                    summary.textContent = title;

                    const contentDiv = document.createElement('div');
                    contentDiv.className = "mt-4 space-y-4";

                    details.appendChild(summary);
                    details.appendChild(contentDiv);
                    return { details, contentDiv };
                };

                const { details: workdayDetails, contentDiv: workdayContent } = createDetailsSection('details-workday', 'Work Day & Breaks', ui.isWorkdayPanelOpen);

                const startTimeSection = document.createElement('div');
                startTimeSection.innerHTML = `<h3 class="font-semibold text-gray-400 mb-2">Work Start Time</h3><div class="p-2 bg-gray-900/50 rounded-lg">${this._renderCustomTimeInput(settings.workDay.startTime, 'workDay.startTime')}</div>`;
                workdayContent.appendChild(startTimeSection);

                const breaksSection = document.createElement('div');
                breaksSection.innerHTML = `<h3 class="font-semibold text-gray-400 mb-2">Breaks</h3>`;
                const breaksContainer = document.createElement('div');
                breaksContainer.className = 'space-y-2';
                settings.breaks.forEach(br => {
                    const breakDiv = document.createElement('div');
                    breakDiv.className = "space-y-2 p-2 bg-gray-900/50 rounded-lg";
                    const labelHTML = `<div class="flex justify-between items-center"><input type="text" placeholder="Label" value="${SecurityUtils.sanitizeHTML(br.label)}" class="setting-input w-full px-2 py-1 bg-gray-700 border-gray-600 text-gray-200 rounded-md" data-list="breaks" data-id="${br.id}" data-field="label" /><button data-action="${Constants.ACTIONS.DELETE_BREAK}" data-id="${br.id}" class="ml-2 text-red-400 hover:text-red-300 shrink-0">${getIcon('Trash2', 16)}</button></div>`;
                    const timeHTML = `<div class="grid grid-cols-1 gap-2"><div><label class="text-sm text-gray-500">Start</label>${this._renderCustomTimeInput(br.start, `breaks.${br.id}.start`)}</div><div><label class="text-sm text-gray-500">End</label>${this._renderCustomTimeInput(br.end, `breaks.${br.id}.end`)}</div></div>`;
                    breakDiv.innerHTML = labelHTML + timeHTML;
                    breaksContainer.appendChild(breakDiv);
                });
                breaksSection.appendChild(breaksContainer);
                const addBreakBtn = document.createElement('button');
                addBreakBtn.dataset.action = Constants.ACTIONS.ADD_BREAK;
                addBreakBtn.className = "mt-2 w-full py-1 bg-gray-700 text-gray-300 rounded hover:bg-gray-600";
                addBreakBtn.textContent = 'Add Break';
                breaksSection.appendChild(addBreakBtn);
                workdayContent.appendChild(breaksSection);

                container.appendChild(workdayDetails);

                const { details: tasksDetails, contentDiv: tasksContent } = createDetailsSection('details-tasks', 'Other Tasks & Settings', ui.isTasksPanelOpen);

                const tasksSection = document.createElement('div');
                tasksSection.innerHTML = `<h3 class="font-semibold text-gray-400 mb-2">Other Scheduled Tasks</h3>`;
                const tasksContainer = document.createElement('div');
                tasksContainer.className = 'space-y-2';
                settings.otherTasks.forEach(task => {
                    const taskDiv = document.createElement('div');
                    taskDiv.className = "space-y-2 p-2 bg-gray-900/50 rounded-lg";
                    taskDiv.innerHTML = `
                        <div class="flex justify-between items-center">
                            <input type="text" placeholder="Label" value="${SecurityUtils.sanitizeHTML(task.label)}" class="setting-input w-full px-2 py-1 bg-gray-700 border-gray-600 text-gray-200 rounded-md" data-list="otherTasks" data-id="${task.id}" data-field="label" />
                            <button data-action="${Constants.ACTIONS.DELETE_TASK}" data-id="${task.id}" class="ml-2 text-red-400 hover:text-red-300 shrink-0">${getIcon('Trash2', 16)}</button>
                        </div>
                        <div class="grid grid-cols-1 gap-2">
                            <div><label class="text-sm text-gray-500">Start</label>${this._renderCustomTimeInput(task.start, `otherTasks.${task.id}.start`)}</div>
                            <div><label class="text-sm text-gray-500">End</label>${this._renderCustomTimeInput(task.end, `otherTasks.${task.id}.end`)}</div>
                        </div>
                        <select class="setting-input w-full px-2 py-1 bg-gray-700 border-gray-600 text-gray-200 rounded-md" data-list="otherTasks" data-id="${task.id}" data-field="type">
                            <option value="non-billable" ${task.type === 'non-billable' ? 'selected' : ''}>Non-Billable</option>
                            <option value="billable" ${task.type === 'billable' ? 'selected' : ''}>Billable</option>
                        </select>`;
                    tasksContainer.appendChild(taskDiv);
                });
                tasksSection.appendChild(tasksContainer);
                const addTaskBtn = document.createElement('button');
                addTaskBtn.dataset.action = Constants.ACTIONS.ADD_TASK;
                addTaskBtn.className = "mt-2 w-full py-1 bg-gray-700 text-gray-300 rounded hover:bg-gray-600";
                addTaskBtn.textContent = 'Add Task';
                tasksSection.appendChild(addTaskBtn);
                tasksContent.appendChild(tasksSection);

                const generalSettingsSection = document.createElement('div');
                generalSettingsSection.innerHTML = `<h3 class="font-semibold text-gray-400 mb-2">General Settings</h3>`;
                const generalSettingsContainer = document.createElement('div');
                generalSettingsContainer.className = 'space-y-2 text-gray-300';
                const generalSettingsFields = {setupTime: 'Setup Time (min)', transitionTime: 'Transition Time (min)', productivityTarget: 'Productivity Target (%)', workdayDurationHours: 'Workday Duration (hours)'};
                Object.entries(generalSettingsFields).forEach(([field, label]) => {
                    const settingDiv = document.createElement('div');
                    settingDiv.className = "flex justify-between items-center";
                    settingDiv.innerHTML = `<label class="text-base">${label}</label><input type="number" value="${settings[field]}" class="setting-input w-20 px-2 py-1 bg-gray-700 border-gray-600 text-gray-200 rounded-md" data-field="${field}" />`;
                    generalSettingsContainer.appendChild(settingDiv);
                });
                generalSettingsSection.appendChild(generalSettingsContainer);
                tasksContent.appendChild(generalSettingsSection);

                container.appendChild(tasksDetails);
            }

            _renderDaySummary(schedule, appointments, patientQueue, settings, manualCalculator) {
                const container = document.getElementById('day-summary-container');
                if (!schedule) { container.innerHTML = ''; return; }

                const patientsSeenCount = appointments.filter(a => a.completed).length;
                const clockOutDisplay = manualCalculator.clockOut || '--:--';
                const productivityDisplay = manualCalculator.productivity || '--.-- %';

                container.innerHTML = `<div class="bg-gray-800 rounded-lg shadow-lg p-4 border border-gray-700">
                    <h2 class="text-3xl font-bold text-gray-200 mb-4">Day Summary</h2>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                        <div>
                            <div class="text-3xl sm:text-4xl font-bold text-gray-300" id="get-clock-out">${clockOutDisplay}</div>
                            <div class="text-base text-gray-400">Target Clock-Out</div>
                        </div>
                        <div>
                            <div class="text-3xl sm:text-4xl font-bold text-yellow-400" id="total-billable-time">${Math.floor(schedule.totalBillableTime/60)}h ${schedule.totalBillableTime % 60}m</div>
                            <div class="text-base text-gray-400">Total Billable</div>
                        </div>
                        <div>
                            <div class="text-3xl sm:text-4xl font-bold text-yellow-400" id="get-productivity-out">${productivityDisplay}</div>
                            <div class="text-base text-gray-400">Productivity</div>
                        </div>
                        <div>
                            <div class="text-3xl sm:text-4xl font-bold text-gray-300">${patientQueue.length}</div>
                            <div class="text-base text-gray-400">Unscheduled</div>
                        </div>
                    </div>
                    <details id="details-productivity-manual" class="mt-4 bg-gray-900/50 rounded-lg p-3 border border-gray-700" open>
                        <summary class="font-semibold text-lg text-gray-300 cursor-pointer flex items-center gap-2">${getIcon('TrendingUp')} Manual Productivity Calculator</summary>
                        <div class="mt-4 space-y-4 pt-4 border-t border-gray-700">
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <label for="tx-time" class="block text-sm font-medium text-gray-400">Total Treatment Time (min)</label>
                                    <input type="number" id="tx-time" data-calculator-field="txTime" class="w-full mt-1 px-3 py-2 bg-gray-700 border-gray-600 text-gray-200 rounded-md" value="${manualCalculator.txTime || schedule.totalBillableTime}">
                                </div>
                                <div>
                                    <label for="productivity-input" class="block text-sm font-medium text-gray-400">Target Productivity (%)</label>
                                    <input type="number" id="productivity-input" data-calculator-field="productivityInput" class="w-full mt-1 px-3 py-2 bg-gray-700 border-gray-600 text-gray-200 rounded-md" value="${manualCalculator.productivityInput || settings.productivityTarget}">
                                </div>
                                <div>
                                    <label for="clockIn" class="block text-sm font-medium text-gray-400">Clock In</label>
                                    <input type="time" id="clockIn" class="w-full mt-1 px-3 py-2 bg-gray-700 border-gray-600 text-gray-200 rounded-md" value="${settings.workDay.startTime}" readonly>
                                </div>
                                <div>
                                    <label for="clock-out" class="block text-sm font-medium text-gray-400">Clock Out</label>
                                    <input type="time" id="clock-out" data-calculator-field="clockOutInput" class="w-full mt-1 px-3 py-2 bg-gray-700 border-gray-600 text-gray-200 rounded-md" value="${manualCalculator.clockOutInput}">
                                </div>
                                <div>
                                    <label for="lunch-out" class="block text-sm font-medium text-gray-400">Lunch Out</label>
                                    <input type="time" id="lunch-out" data-calculator-field="lunchOut" class="w-full mt-1 px-3 py-2 bg-gray-700 border-gray-600 text-gray-200 rounded-md" value="${manualCalculator.lunchOut}">
                                </div>
                                <div>
                                    <label for="lunchIn" class="block text-sm font-medium text-gray-400">Lunch In</label>
                                    <input type="time" id="lunchIn" data-calculator-field="lunchIn" class="w-full mt-1 px-3 py-2 bg-gray-700 border-gray-600 text-gray-200 rounded-md" value="${manualCalculator.lunchIn}">
                                </div>
                            </div>
                            <div class="flex gap-4 mt-4">
                                <button data-action="get-productivity" class="w-full py-2 px-4 bg-yellow-500 text-gray-900 font-semibold rounded-lg hover:bg-yellow-400">Get Productivity</button>
                                <button data-action="get-clock-out" class="w-full py-2 px-4 bg-yellow-500 text-gray-900 font-semibold rounded-lg hover:bg-yellow-400">Get Clock Out</button>
                            </div>
                        </div>
                    </details>
                </div>`;
            }

            _renderScheduleTimeline(schedule, settings) {
                const container = document.getElementById('schedule-timeline-container');
                if (!schedule) { container.innerHTML = ''; return; }
                const dayStartMins = TimeUtils.timeStringToMinutes(settings.workDay.startTime);
                const totalDayDurationMins = settings.workdayDurationHours * Constants.TIME.MINUTES_IN_HOUR;
                const timelineContentHeight = (totalDayDurationMins / Constants.TIME.MINUTES_IN_HOUR) * Constants.PIXELS_PER_HOUR;
                const startHour = Math.floor(dayStartMins / Constants.TIME.MINUTES_IN_HOUR);
                const endHour = startHour + settings.workdayDurationHours;

                container.innerHTML = `<div class="bg-gray-800 rounded-lg shadow-lg p-4 border border-gray-700"><h2 class="text-xl font-semibold text-gray-200 mb-4">Visual Schedule</h2><div class="timeline-scroll-container overflow-y-auto max-h-[82vh] bg-gray-900/50 pl-10 sm:pl-14 py-2 rounded-md"><div id="timeline-droppable" class="relative" style="height: ${timelineContentHeight}px;"></div></div></div>`;

                const timelineDroppable = container.querySelector('#timeline-droppable');
                if (!timelineDroppable) return;

                for (let hour = startHour; hour <= endHour; hour++) {
                    const hourMins = hour * Constants.TIME.MINUTES_IN_HOUR;
                    const top = ((hourMins - dayStartMins) / Constants.TIME.MINUTES_IN_HOUR) * Constants.PIXELS_PER_HOUR;
                    const markerDiv = document.createElement('div');
                    markerDiv.className = 'absolute w-full';
                    markerDiv.style.cssText = `top: ${top}px; left: 0;`;

                    const timeLabel = document.createElement('span');
                    timeLabel.className = 'text-sm text-gray-500 absolute -left-10 sm:-left-14 text-right w-10 sm:w-14 pr-2 transform -translate-y-1/2';
                    timeLabel.textContent = `${hour % Constants.TIME.HOURS_AM_PM || Constants.TIME.HOURS_AM_PM}:00 ${hour < Constants.TIME.HOURS_AM_PM || hour === Constants.TIME.HOURS_IN_DAY ? 'AM' : 'PM'}`;

                    const lineDiv = document.createElement('div');
                    lineDiv.className = 'border-t border-gray-700';

                    markerDiv.appendChild(timeLabel);
                    markerDiv.appendChild(lineDiv);
                    timelineDroppable.appendChild(markerDiv);
                }

                const timelineItemsWithLayout = ScheduleCalculator.calculateAppointmentLayout(schedule.timelineItems);
                timelineItemsWithLayout.forEach(item => {
                    const element = this._createTimelineItemElement(item, dayStartMins);
                    if (element) timelineDroppable.appendChild(element);
                });

                const scrollContainer = container.querySelector('.timeline-scroll-container');
                if (scrollContainer && !this.initialScrollDone) {
                    const now = new Date();
                    const currentTimeInMinutes = now.getHours() * Constants.TIME.MINUTES_IN_HOUR + now.getMinutes();
                    const scrollOffset = ((currentTimeInMinutes - dayStartMins) / Constants.TIME.MINUTES_IN_HOUR) * Constants.PIXELS_PER_HOUR;
                    scrollContainer.scrollTop = Math.max(0, scrollOffset - 50);
                    this.initialScrollDone = true;
                }
            }

            _createTimelineItemElement(item, dayStartMins) {
                const top = ((item.startMins - dayStartMins) / Constants.TIME.MINUTES_IN_HOUR) * Constants.PIXELS_PER_HOUR;
                const height = ((item.endMins - item.startMins) / Constants.TIME.MINUTES_IN_HOUR) * Constants.PIXELS_PER_HOUR;
                if (height <= Constants.TIMELINE_LAYOUT.ITEM_MIN_HEIGHT_PX) return null;

                const wrapper = document.createElement('div');
                wrapper.className = 'absolute';
                wrapper.style.cssText = `top: ${top}px; height: ${height}px;`;

                let content;

                switch (item.type) {
                    case 'appointment':
                        const { lane, totalLanes } = item.layout;
                        const itemWidth = totalLanes > 1 ? (Constants.TIMELINE_LAYOUT.BASE_WIDTH_PERCENT / totalLanes) - Constants.TIMELINE_LAYOUT.OVERLAP_GAP_PERCENT : Constants.TIMELINE_LAYOUT.BASE_WIDTH_PERCENT;
                        const itemLeft = Constants.TIMELINE_LAYOUT.BASE_LEFT_PERCENT + (lane * (Constants.TIMELINE_LAYOUT.BASE_WIDTH_PERCENT / totalLanes)) + (totalLanes > 1 ? Constants.TIMELINE_LAYOUT.OVERLAP_OFFSET_PERCENT : 0);
                        wrapper.style.width = `${itemWidth}%`;
                        wrapper.style.left = `${itemLeft}%`;
                        wrapper.style.zIndex = `${Constants.TIMELINE_LAYOUT.BASE_Z_INDEX + lane}`;

                        content = document.createElement('div');
                        content.className = `timeline-appointment-item relative group pt-1 px-2 pb-2 rounded-md cursor-pointer h-full w-full border ${this._getAppointmentColor(item.duration)} ${item.completed ? 'opacity-60' : ''}`;
                        content.dataset.id = item.id;
                        content.dataset.itemType = 'appointment';
                        content.draggable = true;

                        content.innerHTML = `
                            <div class="flex justify-between">
                                <span class="block text-base ${item.completed ? 'line-through' : ''} opacity-80">${item.duration}m</span>
                                <strong class="text-base font-semibold ${item.completed ? 'line-through' : ''}">${SecurityUtils.sanitizeHTML(item.name)}</strong>
                            </div>
                            <span class="block text-base ${item.completed ? 'line-through' : ''} opacity-80">${TimeUtils.minutesToTime(item.startMins)} - ${TimeUtils.minutesToTime(item.endMins)}</span>
                            <div class="absolute top-1 right-1 flex opacity-0 group-hover:opacity-100 transition-opacity bg-gray-900/90 rounded-md shadow-lg">
                                <button data-action="${Constants.ACTIONS.EDIT_APPOINTMENT}" class="p-1.5" title="Edit session">${getIcon('Edit', 14)}</button>
                                <button data-action="${Constants.ACTIONS.TOGGLE_COMPLETE}" class="p-1.5" title="Mark complete">${getIcon('CheckCircle', 14)}</button>
                                <button data-action="${Constants.ACTIONS.DELETE_APPOINTMENT}" class="p-1.5" title="Remove session">${getIcon('Trash2', 14)}</button>
                            </div>
                            ${item.completed ? `<div class="absolute top-2 right-2 p-1.5 bg-gray-900/50 rounded-lg group-hover:opacity-0">${getIcon('CheckCircle', 16)}</div>` : ''}`;
                        break;
                    case 'break': case 'billable': case 'non-billable':
                        wrapper.style.width = `${Constants.TIMELINE_LAYOUT.BASE_WIDTH_PERCENT}%`;
                        wrapper.style.left = `${Constants.TIMELINE_LAYOUT.BASE_LEFT_PERCENT}%`;
                        wrapper.style.zIndex = '5';

                        content = document.createElement('div');
                        content.className = 'p-2 rounded-md bg-gray-700/50 border-gray-600 text-gray-300 text-sm h-full w-full flex flex-col justify-center cursor-grab active:cursor-grabbing';
                        content.draggable = true;
                        content.dataset.id = item.id;
                        content.dataset.itemType = item.type;

                        const itemHeader = document.createElement('div');
                        itemHeader.className = 'flex items-center gap-1';
                        itemHeader.innerHTML = `<span class="text-yellow-400">${item.type === 'break' ? getIcon('Coffee', 14) : getIcon('Briefcase', 14)}</span>`;
                        const strong = document.createElement('strong');
                        strong.textContent = item.label;
                        itemHeader.appendChild(strong);

                        const timeRange = document.createElement('span');
                        timeRange.className = 'text-xs opacity-70';
                        timeRange.textContent = `${TimeUtils.minutesToTime(item.startMins)} - ${TimeUtils.minutesToTime(item.endMins)}`;

                        content.appendChild(itemHeader);
                        content.appendChild(timeRange);
                        break;
                    case 'gap':
                        wrapper.style.width = `${Constants.TIMELINE_LAYOUT.BASE_WIDTH_PERCENT}%`;
                        wrapper.style.left = `${Constants.TIMELINE_LAYOUT.BASE_LEFT_PERCENT}%`;
                        content = document.createElement('div');
                        content.className = 'timeline-gap rounded-md border-2 border-dashed border-gray-700 hover:bg-yellow-500/10 hover:border-yellow-400 transition-colors flex justify-center items-center text-sm text-center h-full w-full';
                        content.dataset.start = item.start;
                        content.dataset.duration = item.duration;
                        content.innerHTML = `Drop Here<br/>(${item.duration} min)`;
                        break;
                }
                if (content) {
                    wrapper.appendChild(content);
                    return wrapper;
                }
                return null;
            }

            _renderCustomTimeInput(value, id) {
                const totalMinutes = TimeUtils.timeStringToMinutes(value);
                const hours24 = Math.floor(totalMinutes / Constants.TIME.MINUTES_IN_HOUR) % Constants.TIME.HOURS_IN_DAY;
                const minute = totalMinutes % Constants.TIME.MINUTES_IN_HOUR;
                const period = hours24 >= Constants.TIME.HOURS_AM_PM ? 'PM' : 'AM';
                let hour12 = hours24 % Constants.TIME.HOURS_AM_PM;
                if (hour12 === 0) hour12 = Constants.TIME.HOURS_AM_PM;

                return `<div class="flex items-center gap-2"><div class="custom-time-input flex items-center bg-gray-700 border border-gray-600 text-gray-200 rounded-md p-1 w-full" data-id="${id}"><input type="number" value="${hour12}" class="time-input-hour w-full bg-transparent text-center focus:outline-none" min="1" max="12"><span class="font-bold text-gray-500">:</span><input type="number" value="${String(minute).padStart(2, '0')}" class="time-input-minute w-full bg-transparent text-center focus:outline-none" min="0" max="59"><div class="flex flex-col border-l border-gray-600 ml-1 pl-1"><button class="am-pm-btn text-xs leading-tight p-0.5 rounded-sm ${period === 'AM' ? 'bg-yellow-500 text-gray-900 font-semibold' : 'hover:bg-gray-600 text-gray-400'}" data-period="AM">AM</button><button class="am-pm-btn text-xs leading-tight p-0.5 rounded-sm ${period === 'PM' ? 'bg-yellow-500 text-gray-900 font-semibold' : 'hover:bg-gray-600 text-gray-400'}" data-period="PM">PM</button></div></div><div class="flex flex-col border border-gray-600 rounded-md overflow-hidden"><button data-action="${Constants.ACTIONS.ADJUST_TIME}" data-id="${id}" data-amount="1" class="px-2 text-base bg-gray-800 text-gray-300 hover:bg-gray-700 border-b border-gray-600" title="Add 1 minute">+</button><button data-action="${Constants.ACTIONS.ADJUST_TIME}" data-id="${id}" data-amount="-1" class="px-2 text-base bg-gray-800 text-gray-300 hover:bg-gray-700" title="Subtract 1 minute">-</button></div></div>`;
            }

            _getAppointmentColor(duration) {
                if (duration <= Constants.APPOINTMENT_COLOR_THRESHOLDS.SHORT) return 'bg-yellow-500/20 border-yellow-400 text-yellow-200';
                if (duration <= Constants.APPOINTMENT_COLOR_THRESHOLDS.MEDIUM) return 'bg-blue-500/20 border-blue-400 text-blue-200';
                if (duration <= Constants.APPOINTMENT_COLOR_THRESHOLDS.LONG) return 'bg-green-500/20 border-green-400 text-green-200';
                return 'bg-purple-500/20 border-purple-400 text-purple-200';
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            try { new TherapySchedulerApp(); }
            catch (error) {
                ErrorHandler.logError(error, 'AppInitialization');
                document.body.innerHTML = `<div class="p-8 text-red-400"><h1>Application Error. Please refresh.</h1></div>`;
            }
        });

    </script>
</body>
</html>